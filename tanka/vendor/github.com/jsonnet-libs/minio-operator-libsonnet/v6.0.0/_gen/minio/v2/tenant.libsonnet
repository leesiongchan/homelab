{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='tenant', url='', help=''),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of Tenant', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'minio.min.io/v2',
    kind: 'Tenant',
  } + self.metadata.withName(name=name),
  '#scheduler':: d.obj(help=''),
  scheduler: {
    '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { scheduler+: { name: name } },
  },
  '#spec':: d.obj(help=''),
  spec: {
    '#additionalVolumeMounts':: d.obj(help=''),
    additionalVolumeMounts: {
      '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
      withMountPath(mountPath): { mountPath: mountPath },
      '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
      withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
      withReadOnly(readOnly): { readOnly: readOnly },
      '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
      withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
      '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
      withSubPath(subPath): { subPath: subPath },
      '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
      withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
    },
    '#additionalVolumes':: d.obj(help=''),
    additionalVolumes: {
      '#awsElasticBlockStore':: d.obj(help=''),
      awsElasticBlockStore: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
        '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
        withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
        '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
        withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
      },
      '#azureDisk':: d.obj(help=''),
      azureDisk: {
        '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
        withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
        '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
        withDiskName(diskName): { azureDisk+: { diskName: diskName } },
        '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
        withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { azureDisk+: { fsType: fsType } },
        '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
        withKind(kind): { azureDisk+: { kind: kind } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
      },
      '#azureFile':: d.obj(help=''),
      azureFile: {
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
        '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
        withSecretName(secretName): { azureFile+: { secretName: secretName } },
        '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
        withShareName(shareName): { azureFile+: { shareName: shareName } },
      },
      '#cephfs':: d.obj(help=''),
      cephfs: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { cephfs+: { secretRef+: { name: name } } },
        },
        '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
        withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
        '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
        withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { cephfs+: { path: path } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
        '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
        withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
        '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
        withUser(user): { cephfs+: { user: user } },
      },
      '#cinder':: d.obj(help=''),
      cinder: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { cinder+: { secretRef+: { name: name } } },
        },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { cinder+: { fsType: fsType } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
        '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
        withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
      },
      '#configMap':: d.obj(help=''),
      configMap: {
        '#items':: d.obj(help=''),
        items: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
          withMode(mode): { mode: mode },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
        },
        '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
        withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
        '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
        withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
        '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
        withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { configMap+: { name: name } },
        '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { configMap+: { optional: optional } },
      },
      '#csi':: d.obj(help=''),
      csi: {
        '#nodePublishSecretRef':: d.obj(help=''),
        nodePublishSecretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
        },
        '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
        withDriver(driver): { csi+: { driver: driver } },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { csi+: { fsType: fsType } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
        '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
        withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
        '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
        withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
      },
      '#downwardAPI':: d.obj(help=''),
      downwardAPI: {
        '#items':: d.obj(help=''),
        items: {
          '#fieldRef':: d.obj(help=''),
          fieldRef: {
            '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
            '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
          },
          '#resourceFieldRef':: d.obj(help=''),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
            '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
            '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { resourceFieldRef+: { resource: resource } },
          },
          '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
          withMode(mode): { mode: mode },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
        },
        '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
        withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
        '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
        withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
        '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
        withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
      },
      '#emptyDir':: d.obj(help=''),
      emptyDir: {
        '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
        withMedium(medium): { emptyDir+: { medium: medium } },
        '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
        withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
      },
      '#ephemeral':: d.obj(help=''),
      ephemeral: {
        '#volumeClaimTemplate':: d.obj(help=''),
        volumeClaimTemplate: {
          '#metadata':: d.obj(help=''),
          metadata: {
            '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
            withAnnotations(annotations): { ephemeral+: { volumeClaimTemplate+: { metadata+: { annotations: annotations } } } },
            '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
            withAnnotationsMixin(annotations): { ephemeral+: { volumeClaimTemplate+: { metadata+: { annotations+: annotations } } } },
            '#withFinalizers':: d.fn(help='', args=[d.arg(name='finalizers', type=d.T.array)]),
            withFinalizers(finalizers): { ephemeral+: { volumeClaimTemplate+: { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } } } },
            '#withFinalizersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
            withFinalizersMixin(finalizers): { ephemeral+: { volumeClaimTemplate+: { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } } } },
            '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
            withLabels(labels): { ephemeral+: { volumeClaimTemplate+: { metadata+: { labels: labels } } } },
            '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
            withLabelsMixin(labels): { ephemeral+: { volumeClaimTemplate+: { metadata+: { labels+: labels } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { ephemeral+: { volumeClaimTemplate+: { metadata+: { name: name } } } },
            '#withNamespace':: d.fn(help='', args=[d.arg(name='namespace', type=d.T.string)]),
            withNamespace(namespace): { ephemeral+: { volumeClaimTemplate+: { metadata+: { namespace: namespace } } } },
          },
          '#spec':: d.obj(help=''),
          spec: {
            '#dataSource':: d.obj(help=''),
            dataSource: {
              '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
              withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
              '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
              withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
            },
            '#dataSourceRef':: d.obj(help=''),
            dataSourceRef: {
              '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
              withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSourceRef+: { apiGroup: apiGroup } } } } },
              '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
              withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSourceRef+: { kind: kind } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSourceRef+: { name: name } } } } },
              '#withNamespace':: d.fn(help='', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSourceRef+: { namespace: namespace } } } } },
            },
            '#resources':: d.obj(help=''),
            resources: {
              '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
              withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
              '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
              withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
              '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
              withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
              '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
              withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
            },
            '#selector':: d.obj(help=''),
            selector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
            },
            '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
            withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
            '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
            withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
            '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
            withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
            '#withVolumeAttributesClassName':: d.fn(help='', args=[d.arg(name='volumeAttributesClassName', type=d.T.string)]),
            withVolumeAttributesClassName(volumeAttributesClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeAttributesClassName: volumeAttributesClassName } } } },
            '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
            withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
            '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
            withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
          },
        },
      },
      '#fc':: d.obj(help=''),
      fc: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { fc+: { fsType: fsType } },
        '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
        withLun(lun): { fc+: { lun: lun } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
        '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
        withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
        '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
        withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
        '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
        withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
        '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
        withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
      },
      '#flexVolume':: d.obj(help=''),
      flexVolume: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { flexVolume+: { secretRef+: { name: name } } },
        },
        '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
        withDriver(driver): { flexVolume+: { driver: driver } },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { flexVolume+: { fsType: fsType } },
        '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
        withOptions(options): { flexVolume+: { options: options } },
        '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
        withOptionsMixin(options): { flexVolume+: { options+: options } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
      },
      '#flocker':: d.obj(help=''),
      flocker: {
        '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
        withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
        '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
        withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
      },
      '#gcePersistentDisk':: d.obj(help=''),
      gcePersistentDisk: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
        '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
        withPartition(partition): { gcePersistentDisk+: { partition: partition } },
        '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
        withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
      },
      '#gitRepo':: d.obj(help=''),
      gitRepo: {
        '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
        withDirectory(directory): { gitRepo+: { directory: directory } },
        '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
        withRepository(repository): { gitRepo+: { repository: repository } },
        '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
        withRevision(revision): { gitRepo+: { revision: revision } },
      },
      '#glusterfs':: d.obj(help=''),
      glusterfs: {
        '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
        withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { glusterfs+: { path: path } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
      },
      '#hostPath':: d.obj(help=''),
      hostPath: {
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { hostPath+: { path: path } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { hostPath+: { type: type } },
      },
      '#iscsi':: d.obj(help=''),
      iscsi: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { iscsi+: { secretRef+: { name: name } } },
        },
        '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
        withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
        '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
        withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { iscsi+: { fsType: fsType } },
        '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
        withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
        '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
        withIqn(iqn): { iscsi+: { iqn: iqn } },
        '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
        withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
        '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
        withLun(lun): { iscsi+: { lun: lun } },
        '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
        withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
        '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
        withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
        '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
        withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
      },
      '#nfs':: d.obj(help=''),
      nfs: {
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { nfs+: { path: path } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
        '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
        withServer(server): { nfs+: { server: server } },
      },
      '#persistentVolumeClaim':: d.obj(help=''),
      persistentVolumeClaim: {
        '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
        withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
      },
      '#photonPersistentDisk':: d.obj(help=''),
      photonPersistentDisk: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
        '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
        withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
      },
      '#portworxVolume':: d.obj(help=''),
      portworxVolume: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { portworxVolume+: { fsType: fsType } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
        '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
        withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
      },
      '#projected':: d.obj(help=''),
      projected: {
        '#sources':: d.obj(help=''),
        sources: {
          '#clusterTrustBundle':: d.obj(help=''),
          clusterTrustBundle: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { clusterTrustBundle+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { clusterTrustBundle+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { clusterTrustBundle+: { labelSelector+: { matchLabels: matchLabels } } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { clusterTrustBundle+: { labelSelector+: { matchLabels+: matchLabels } } },
            },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { clusterTrustBundle+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { clusterTrustBundle+: { optional: optional } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { clusterTrustBundle+: { path: path } },
            '#withSignerName':: d.fn(help='', args=[d.arg(name='signerName', type=d.T.string)]),
            withSignerName(signerName): { clusterTrustBundle+: { signerName: signerName } },
          },
          '#configMap':: d.obj(help=''),
          configMap: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMap+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMap+: { optional: optional } },
          },
          '#downwardAPI':: d.obj(help=''),
          downwardAPI: {
            '#items':: d.obj(help=''),
            items: {
              '#fieldRef':: d.obj(help=''),
              fieldRef: {
                '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
              },
              '#resourceFieldRef':: d.obj(help=''),
              resourceFieldRef: {
                '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                withResource(resource): { resourceFieldRef+: { resource: resource } },
              },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
          },
          '#secret':: d.obj(help=''),
          secret: {
            '#items':: d.obj(help=''),
            items: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
              withMode(mode): { mode: mode },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { path: path },
            },
            '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
            withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
            '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
            withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { secret+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secret+: { optional: optional } },
          },
          '#serviceAccountToken':: d.obj(help=''),
          serviceAccountToken: {
            '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
            withAudience(audience): { serviceAccountToken+: { audience: audience } },
            '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
            withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { serviceAccountToken+: { path: path } },
          },
        },
        '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
        withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
        '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
        withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
        '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
        withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
      },
      '#quobyte':: d.obj(help=''),
      quobyte: {
        '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
        withGroup(group): { quobyte+: { group: group } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
        '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
        withRegistry(registry): { quobyte+: { registry: registry } },
        '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
        withTenant(tenant): { quobyte+: { tenant: tenant } },
        '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
        withUser(user): { quobyte+: { user: user } },
        '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
        withVolume(volume): { quobyte+: { volume: volume } },
      },
      '#rbd':: d.obj(help=''),
      rbd: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { rbd+: { secretRef+: { name: name } } },
        },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { rbd+: { fsType: fsType } },
        '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { rbd+: { image: image } },
        '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
        withKeyring(keyring): { rbd+: { keyring: keyring } },
        '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
        withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
        '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
        withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
        '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
        withPool(pool): { rbd+: { pool: pool } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
        '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
        withUser(user): { rbd+: { user: user } },
      },
      '#scaleIO':: d.obj(help=''),
      scaleIO: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { scaleIO+: { secretRef+: { name: name } } },
        },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { scaleIO+: { fsType: fsType } },
        '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
        withGateway(gateway): { scaleIO+: { gateway: gateway } },
        '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
        withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
        '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
        withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
        '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
        withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
        '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
        withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
        '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
        withSystem(system): { scaleIO+: { system: system } },
        '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
        withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
      },
      '#secret':: d.obj(help=''),
      secret: {
        '#items':: d.obj(help=''),
        items: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
          withMode(mode): { mode: mode },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
        },
        '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
        withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
        '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
        withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
        '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
        withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
        '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { secret+: { optional: optional } },
        '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
        withSecretName(secretName): { secret+: { secretName: secretName } },
      },
      '#storageos':: d.obj(help=''),
      storageos: {
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { storageos+: { secretRef+: { name: name } } },
        },
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { storageos+: { fsType: fsType } },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
        '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
        withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
        '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
        withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
      },
      '#vsphereVolume':: d.obj(help=''),
      vsphereVolume: {
        '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
        withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
        '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
        withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
        '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
        withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
        '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
        withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
      },
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
    },
    '#buckets':: d.obj(help=''),
    buckets: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withObjectLock':: d.fn(help='', args=[d.arg(name='objectLock', type=d.T.boolean)]),
      withObjectLock(objectLock): { objectLock: objectLock },
      '#withRegion':: d.fn(help='', args=[d.arg(name='region', type=d.T.string)]),
      withRegion(region): { region: region },
    },
    '#certConfig':: d.obj(help=''),
    certConfig: {
      '#withCommonName':: d.fn(help='', args=[d.arg(name='commonName', type=d.T.string)]),
      withCommonName(commonName): { spec+: { certConfig+: { commonName: commonName } } },
      '#withDnsNames':: d.fn(help='', args=[d.arg(name='dnsNames', type=d.T.array)]),
      withDnsNames(dnsNames): { spec+: { certConfig+: { dnsNames: if std.isArray(v=dnsNames) then dnsNames else [dnsNames] } } },
      '#withDnsNamesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dnsNames', type=d.T.array)]),
      withDnsNamesMixin(dnsNames): { spec+: { certConfig+: { dnsNames+: if std.isArray(v=dnsNames) then dnsNames else [dnsNames] } } },
      '#withOrganizationName':: d.fn(help='', args=[d.arg(name='organizationName', type=d.T.array)]),
      withOrganizationName(organizationName): { spec+: { certConfig+: { organizationName: if std.isArray(v=organizationName) then organizationName else [organizationName] } } },
      '#withOrganizationNameMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='organizationName', type=d.T.array)]),
      withOrganizationNameMixin(organizationName): { spec+: { certConfig+: { organizationName+: if std.isArray(v=organizationName) then organizationName else [organizationName] } } },
    },
    '#configuration':: d.obj(help=''),
    configuration: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { configuration+: { name: name } } },
    },
    '#env':: d.obj(help=''),
    env: {
      '#valueFrom':: d.obj(help=''),
      valueFrom: {
        '#configMapKeyRef':: d.obj(help=''),
        configMapKeyRef: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
        },
        '#fieldRef':: d.obj(help=''),
        fieldRef: {
          '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
          withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
          '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
          withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
        },
        '#resourceFieldRef':: d.obj(help=''),
        resourceFieldRef: {
          '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
          withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
          '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
          withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
          '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
          withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
        },
        '#secretKeyRef':: d.obj(help=''),
        secretKeyRef: {
          '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
        },
      },
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
      withValue(value): { value: value },
    },
    '#exposeServices':: d.obj(help=''),
    exposeServices: {
      '#withConsole':: d.fn(help='', args=[d.arg(name='console', type=d.T.boolean)]),
      withConsole(console): { spec+: { exposeServices+: { console: console } } },
      '#withMinio':: d.fn(help='', args=[d.arg(name='minio', type=d.T.boolean)]),
      withMinio(minio): { spec+: { exposeServices+: { minio: minio } } },
    },
    '#externalCaCertSecret':: d.obj(help=''),
    externalCaCertSecret: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { type: type },
    },
    '#externalCertSecret':: d.obj(help=''),
    externalCertSecret: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { type: type },
    },
    '#externalClientCertSecret':: d.obj(help=''),
    externalClientCertSecret: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { externalClientCertSecret+: { name: name } } },
      '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { spec+: { externalClientCertSecret+: { type: type } } },
    },
    '#externalClientCertSecrets':: d.obj(help=''),
    externalClientCertSecrets: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { type: type },
    },
    '#features':: d.obj(help=''),
    features: {
      '#domains':: d.obj(help=''),
      domains: {
        '#withConsole':: d.fn(help='', args=[d.arg(name='console', type=d.T.string)]),
        withConsole(console): { spec+: { features+: { domains+: { console: console } } } },
        '#withMinio':: d.fn(help='', args=[d.arg(name='minio', type=d.T.array)]),
        withMinio(minio): { spec+: { features+: { domains+: { minio: if std.isArray(v=minio) then minio else [minio] } } } },
        '#withMinioMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='minio', type=d.T.array)]),
        withMinioMixin(minio): { spec+: { features+: { domains+: { minio+: if std.isArray(v=minio) then minio else [minio] } } } },
      },
      '#withBucketDNS':: d.fn(help='', args=[d.arg(name='bucketDNS', type=d.T.boolean)]),
      withBucketDNS(bucketDNS): { spec+: { features+: { bucketDNS: bucketDNS } } },
      '#withEnableSFTP':: d.fn(help='', args=[d.arg(name='enableSFTP', type=d.T.boolean)]),
      withEnableSFTP(enableSFTP): { spec+: { features+: { enableSFTP: enableSFTP } } },
    },
    '#imagePullSecret':: d.obj(help=''),
    imagePullSecret: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { imagePullSecret+: { name: name } } },
    },
    '#initContainers':: d.obj(help=''),
    initContainers: {
      '#env':: d.obj(help=''),
      env: {
        '#valueFrom':: d.obj(help=''),
        valueFrom: {
          '#configMapKeyRef':: d.obj(help=''),
          configMapKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
          },
          '#fieldRef':: d.obj(help=''),
          fieldRef: {
            '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
            '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
          },
          '#resourceFieldRef':: d.obj(help=''),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
            '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
            '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
          },
          '#secretKeyRef':: d.obj(help=''),
          secretKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
          },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#envFrom':: d.obj(help=''),
      envFrom: {
        '#configMapRef':: d.obj(help=''),
        configMapRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { configMapRef+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { configMapRef+: { optional: optional } },
        },
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { secretRef+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { secretRef+: { optional: optional } },
        },
        '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { prefix: prefix },
      },
      '#lifecycle':: d.obj(help=''),
      lifecycle: {
        '#postStart':: d.obj(help=''),
        postStart: {
          '#exec':: d.obj(help=''),
          exec: {
            '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
            withCommand(command): { lifecycle+: { postStart+: { exec+: { command: if std.isArray(v=command) then command else [command] } } } },
            '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
            withCommandMixin(command): { lifecycle+: { postStart+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } } },
          },
          '#httpGet':: d.obj(help=''),
          httpGet: {
            '#httpHeaders':: d.obj(help=''),
            httpHeaders: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { lifecycle+: { postStart+: { httpGet+: { host: host } } } },
            '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeaders(httpHeaders): { lifecycle+: { postStart+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
            '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeadersMixin(httpHeaders): { lifecycle+: { postStart+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { lifecycle+: { postStart+: { httpGet+: { path: path } } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { lifecycle+: { postStart+: { httpGet+: { port: port } } } },
            '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
            withScheme(scheme): { lifecycle+: { postStart+: { httpGet+: { scheme: scheme } } } },
          },
          '#sleep':: d.obj(help=''),
          sleep: {
            '#withSeconds':: d.fn(help='', args=[d.arg(name='seconds', type=d.T.integer)]),
            withSeconds(seconds): { lifecycle+: { postStart+: { sleep+: { seconds: seconds } } } },
          },
          '#tcpSocket':: d.obj(help=''),
          tcpSocket: {
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { lifecycle+: { postStart+: { tcpSocket+: { host: host } } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { lifecycle+: { postStart+: { tcpSocket+: { port: port } } } },
          },
        },
        '#preStop':: d.obj(help=''),
        preStop: {
          '#exec':: d.obj(help=''),
          exec: {
            '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
            withCommand(command): { lifecycle+: { preStop+: { exec+: { command: if std.isArray(v=command) then command else [command] } } } },
            '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
            withCommandMixin(command): { lifecycle+: { preStop+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } } },
          },
          '#httpGet':: d.obj(help=''),
          httpGet: {
            '#httpHeaders':: d.obj(help=''),
            httpHeaders: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { lifecycle+: { preStop+: { httpGet+: { host: host } } } },
            '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeaders(httpHeaders): { lifecycle+: { preStop+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
            '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeadersMixin(httpHeaders): { lifecycle+: { preStop+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { lifecycle+: { preStop+: { httpGet+: { path: path } } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { lifecycle+: { preStop+: { httpGet+: { port: port } } } },
            '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
            withScheme(scheme): { lifecycle+: { preStop+: { httpGet+: { scheme: scheme } } } },
          },
          '#sleep':: d.obj(help=''),
          sleep: {
            '#withSeconds':: d.fn(help='', args=[d.arg(name='seconds', type=d.T.integer)]),
            withSeconds(seconds): { lifecycle+: { preStop+: { sleep+: { seconds: seconds } } } },
          },
          '#tcpSocket':: d.obj(help=''),
          tcpSocket: {
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { lifecycle+: { preStop+: { tcpSocket+: { host: host } } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { lifecycle+: { preStop+: { tcpSocket+: { port: port } } } },
          },
        },
      },
      '#livenessProbe':: d.obj(help=''),
      livenessProbe: {
        '#exec':: d.obj(help=''),
        exec: {
          '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
          withCommand(command): { livenessProbe+: { exec+: { command: if std.isArray(v=command) then command else [command] } } },
          '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
          withCommandMixin(command): { livenessProbe+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } },
        },
        '#grpc':: d.obj(help=''),
        grpc: {
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.integer)]),
          withPort(port): { livenessProbe+: { grpc+: { port: port } } },
          '#withService':: d.fn(help='', args=[d.arg(name='service', type=d.T.string)]),
          withService(service): { livenessProbe+: { grpc+: { service: service } } },
        },
        '#httpGet':: d.obj(help=''),
        httpGet: {
          '#httpHeaders':: d.obj(help=''),
          httpHeaders: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { livenessProbe+: { httpGet+: { host: host } } },
          '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeaders(httpHeaders): { livenessProbe+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
          '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeadersMixin(httpHeaders): { livenessProbe+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { livenessProbe+: { httpGet+: { path: path } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { livenessProbe+: { httpGet+: { port: port } } },
          '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
          withScheme(scheme): { livenessProbe+: { httpGet+: { scheme: scheme } } },
        },
        '#tcpSocket':: d.obj(help=''),
        tcpSocket: {
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { livenessProbe+: { tcpSocket+: { host: host } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { livenessProbe+: { tcpSocket+: { port: port } } },
        },
        '#withFailureThreshold':: d.fn(help='', args=[d.arg(name='failureThreshold', type=d.T.integer)]),
        withFailureThreshold(failureThreshold): { livenessProbe+: { failureThreshold: failureThreshold } },
        '#withInitialDelaySeconds':: d.fn(help='', args=[d.arg(name='initialDelaySeconds', type=d.T.integer)]),
        withInitialDelaySeconds(initialDelaySeconds): { livenessProbe+: { initialDelaySeconds: initialDelaySeconds } },
        '#withPeriodSeconds':: d.fn(help='', args=[d.arg(name='periodSeconds', type=d.T.integer)]),
        withPeriodSeconds(periodSeconds): { livenessProbe+: { periodSeconds: periodSeconds } },
        '#withSuccessThreshold':: d.fn(help='', args=[d.arg(name='successThreshold', type=d.T.integer)]),
        withSuccessThreshold(successThreshold): { livenessProbe+: { successThreshold: successThreshold } },
        '#withTerminationGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='terminationGracePeriodSeconds', type=d.T.integer)]),
        withTerminationGracePeriodSeconds(terminationGracePeriodSeconds): { livenessProbe+: { terminationGracePeriodSeconds: terminationGracePeriodSeconds } },
        '#withTimeoutSeconds':: d.fn(help='', args=[d.arg(name='timeoutSeconds', type=d.T.integer)]),
        withTimeoutSeconds(timeoutSeconds): { livenessProbe+: { timeoutSeconds: timeoutSeconds } },
      },
      '#ports':: d.obj(help=''),
      ports: {
        '#withContainerPort':: d.fn(help='', args=[d.arg(name='containerPort', type=d.T.integer)]),
        withContainerPort(containerPort): { containerPort: containerPort },
        '#withHostIP':: d.fn(help='', args=[d.arg(name='hostIP', type=d.T.string)]),
        withHostIP(hostIP): { hostIP: hostIP },
        '#withHostPort':: d.fn(help='', args=[d.arg(name='hostPort', type=d.T.integer)]),
        withHostPort(hostPort): { hostPort: hostPort },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withProtocol':: d.fn(help='', args=[d.arg(name='protocol', type=d.T.string)]),
        withProtocol(protocol): { protocol: protocol },
      },
      '#readinessProbe':: d.obj(help=''),
      readinessProbe: {
        '#exec':: d.obj(help=''),
        exec: {
          '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
          withCommand(command): { readinessProbe+: { exec+: { command: if std.isArray(v=command) then command else [command] } } },
          '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
          withCommandMixin(command): { readinessProbe+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } },
        },
        '#grpc':: d.obj(help=''),
        grpc: {
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.integer)]),
          withPort(port): { readinessProbe+: { grpc+: { port: port } } },
          '#withService':: d.fn(help='', args=[d.arg(name='service', type=d.T.string)]),
          withService(service): { readinessProbe+: { grpc+: { service: service } } },
        },
        '#httpGet':: d.obj(help=''),
        httpGet: {
          '#httpHeaders':: d.obj(help=''),
          httpHeaders: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { readinessProbe+: { httpGet+: { host: host } } },
          '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeaders(httpHeaders): { readinessProbe+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
          '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeadersMixin(httpHeaders): { readinessProbe+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { readinessProbe+: { httpGet+: { path: path } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { readinessProbe+: { httpGet+: { port: port } } },
          '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
          withScheme(scheme): { readinessProbe+: { httpGet+: { scheme: scheme } } },
        },
        '#tcpSocket':: d.obj(help=''),
        tcpSocket: {
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { readinessProbe+: { tcpSocket+: { host: host } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { readinessProbe+: { tcpSocket+: { port: port } } },
        },
        '#withFailureThreshold':: d.fn(help='', args=[d.arg(name='failureThreshold', type=d.T.integer)]),
        withFailureThreshold(failureThreshold): { readinessProbe+: { failureThreshold: failureThreshold } },
        '#withInitialDelaySeconds':: d.fn(help='', args=[d.arg(name='initialDelaySeconds', type=d.T.integer)]),
        withInitialDelaySeconds(initialDelaySeconds): { readinessProbe+: { initialDelaySeconds: initialDelaySeconds } },
        '#withPeriodSeconds':: d.fn(help='', args=[d.arg(name='periodSeconds', type=d.T.integer)]),
        withPeriodSeconds(periodSeconds): { readinessProbe+: { periodSeconds: periodSeconds } },
        '#withSuccessThreshold':: d.fn(help='', args=[d.arg(name='successThreshold', type=d.T.integer)]),
        withSuccessThreshold(successThreshold): { readinessProbe+: { successThreshold: successThreshold } },
        '#withTerminationGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='terminationGracePeriodSeconds', type=d.T.integer)]),
        withTerminationGracePeriodSeconds(terminationGracePeriodSeconds): { readinessProbe+: { terminationGracePeriodSeconds: terminationGracePeriodSeconds } },
        '#withTimeoutSeconds':: d.fn(help='', args=[d.arg(name='timeoutSeconds', type=d.T.integer)]),
        withTimeoutSeconds(timeoutSeconds): { readinessProbe+: { timeoutSeconds: timeoutSeconds } },
      },
      '#resizePolicy':: d.obj(help=''),
      resizePolicy: {
        '#withResourceName':: d.fn(help='', args=[d.arg(name='resourceName', type=d.T.string)]),
        withResourceName(resourceName): { resourceName: resourceName },
        '#withRestartPolicy':: d.fn(help='', args=[d.arg(name='restartPolicy', type=d.T.string)]),
        withRestartPolicy(restartPolicy): { restartPolicy: restartPolicy },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#claims':: d.obj(help=''),
        claims: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#withClaims':: d.fn(help='', args=[d.arg(name='claims', type=d.T.array)]),
        withClaims(claims): { resources+: { claims: if std.isArray(v=claims) then claims else [claims] } },
        '#withClaimsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='claims', type=d.T.array)]),
        withClaimsMixin(claims): { resources+: { claims+: if std.isArray(v=claims) then claims else [claims] } },
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { resources+: { limits: limits } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { resources+: { limits+: limits } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { resources+: { requests: requests } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { resources+: { requests+: requests } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#appArmorProfile':: d.obj(help=''),
        appArmorProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { securityContext+: { appArmorProfile+: { type: type } } },
        },
        '#capabilities':: d.obj(help=''),
        capabilities: {
          '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
          withAdd(add): { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } },
          '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
          withAddMixin(add): { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } },
          '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
          withDrop(drop): { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } },
          '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
          withDropMixin(drop): { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } },
        },
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { securityContext+: { seLinuxOptions+: { level: level } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { securityContext+: { seLinuxOptions+: { role: role } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { securityContext+: { seLinuxOptions+: { type: type } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { securityContext+: { seLinuxOptions+: { user: user } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { securityContext+: { seccompProfile+: { type: type } } },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } },
          '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
          withHostProcess(hostProcess): { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } },
        },
        '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
        withAllowPrivilegeEscalation(allowPrivilegeEscalation): { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } },
        '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
        withPrivileged(privileged): { securityContext+: { privileged: privileged } },
        '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
        withProcMount(procMount): { securityContext+: { procMount: procMount } },
        '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
        withReadOnlyRootFilesystem(readOnlyRootFilesystem): { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { securityContext+: { runAsGroup: runAsGroup } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { securityContext+: { runAsNonRoot: runAsNonRoot } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { securityContext+: { runAsUser: runAsUser } },
      },
      '#startupProbe':: d.obj(help=''),
      startupProbe: {
        '#exec':: d.obj(help=''),
        exec: {
          '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
          withCommand(command): { startupProbe+: { exec+: { command: if std.isArray(v=command) then command else [command] } } },
          '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
          withCommandMixin(command): { startupProbe+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } },
        },
        '#grpc':: d.obj(help=''),
        grpc: {
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.integer)]),
          withPort(port): { startupProbe+: { grpc+: { port: port } } },
          '#withService':: d.fn(help='', args=[d.arg(name='service', type=d.T.string)]),
          withService(service): { startupProbe+: { grpc+: { service: service } } },
        },
        '#httpGet':: d.obj(help=''),
        httpGet: {
          '#httpHeaders':: d.obj(help=''),
          httpHeaders: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { startupProbe+: { httpGet+: { host: host } } },
          '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeaders(httpHeaders): { startupProbe+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
          '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeadersMixin(httpHeaders): { startupProbe+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { startupProbe+: { httpGet+: { path: path } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { startupProbe+: { httpGet+: { port: port } } },
          '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
          withScheme(scheme): { startupProbe+: { httpGet+: { scheme: scheme } } },
        },
        '#tcpSocket':: d.obj(help=''),
        tcpSocket: {
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { startupProbe+: { tcpSocket+: { host: host } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { startupProbe+: { tcpSocket+: { port: port } } },
        },
        '#withFailureThreshold':: d.fn(help='', args=[d.arg(name='failureThreshold', type=d.T.integer)]),
        withFailureThreshold(failureThreshold): { startupProbe+: { failureThreshold: failureThreshold } },
        '#withInitialDelaySeconds':: d.fn(help='', args=[d.arg(name='initialDelaySeconds', type=d.T.integer)]),
        withInitialDelaySeconds(initialDelaySeconds): { startupProbe+: { initialDelaySeconds: initialDelaySeconds } },
        '#withPeriodSeconds':: d.fn(help='', args=[d.arg(name='periodSeconds', type=d.T.integer)]),
        withPeriodSeconds(periodSeconds): { startupProbe+: { periodSeconds: periodSeconds } },
        '#withSuccessThreshold':: d.fn(help='', args=[d.arg(name='successThreshold', type=d.T.integer)]),
        withSuccessThreshold(successThreshold): { startupProbe+: { successThreshold: successThreshold } },
        '#withTerminationGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='terminationGracePeriodSeconds', type=d.T.integer)]),
        withTerminationGracePeriodSeconds(terminationGracePeriodSeconds): { startupProbe+: { terminationGracePeriodSeconds: terminationGracePeriodSeconds } },
        '#withTimeoutSeconds':: d.fn(help='', args=[d.arg(name='timeoutSeconds', type=d.T.integer)]),
        withTimeoutSeconds(timeoutSeconds): { startupProbe+: { timeoutSeconds: timeoutSeconds } },
      },
      '#volumeDevices':: d.obj(help=''),
      volumeDevices: {
        '#withDevicePath':: d.fn(help='', args=[d.arg(name='devicePath', type=d.T.string)]),
        withDevicePath(devicePath): { devicePath: devicePath },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#volumeMounts':: d.obj(help=''),
      volumeMounts: {
        '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
        withMountPath(mountPath): { mountPath: mountPath },
        '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
        withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { readOnly: readOnly },
        '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
        withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
        '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
        withSubPath(subPath): { subPath: subPath },
        '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
        withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
      },
      '#withArgs':: d.fn(help='', args=[d.arg(name='args', type=d.T.array)]),
      withArgs(args): { args: if std.isArray(v=args) then args else [args] },
      '#withArgsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
      withArgsMixin(args): { args+: if std.isArray(v=args) then args else [args] },
      '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
      withCommand(command): { command: if std.isArray(v=command) then command else [command] },
      '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
      withCommandMixin(command): { command+: if std.isArray(v=command) then command else [command] },
      '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
      withEnv(env): { env: if std.isArray(v=env) then env else [env] },
      '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
      withEnvFrom(envFrom): { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] },
      '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
      withEnvFromMixin(envFrom): { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] },
      '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
      withEnvMixin(env): { env+: if std.isArray(v=env) then env else [env] },
      '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
      withImage(image): { image: image },
      '#withImagePullPolicy':: d.fn(help='', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
      withImagePullPolicy(imagePullPolicy): { imagePullPolicy: imagePullPolicy },
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withPorts':: d.fn(help='', args=[d.arg(name='ports', type=d.T.array)]),
      withPorts(ports): { ports: if std.isArray(v=ports) then ports else [ports] },
      '#withPortsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ports', type=d.T.array)]),
      withPortsMixin(ports): { ports+: if std.isArray(v=ports) then ports else [ports] },
      '#withResizePolicy':: d.fn(help='', args=[d.arg(name='resizePolicy', type=d.T.array)]),
      withResizePolicy(resizePolicy): { resizePolicy: if std.isArray(v=resizePolicy) then resizePolicy else [resizePolicy] },
      '#withResizePolicyMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resizePolicy', type=d.T.array)]),
      withResizePolicyMixin(resizePolicy): { resizePolicy+: if std.isArray(v=resizePolicy) then resizePolicy else [resizePolicy] },
      '#withRestartPolicy':: d.fn(help='', args=[d.arg(name='restartPolicy', type=d.T.string)]),
      withRestartPolicy(restartPolicy): { restartPolicy: restartPolicy },
      '#withStdin':: d.fn(help='', args=[d.arg(name='stdin', type=d.T.boolean)]),
      withStdin(stdin): { stdin: stdin },
      '#withStdinOnce':: d.fn(help='', args=[d.arg(name='stdinOnce', type=d.T.boolean)]),
      withStdinOnce(stdinOnce): { stdinOnce: stdinOnce },
      '#withTerminationMessagePath':: d.fn(help='', args=[d.arg(name='terminationMessagePath', type=d.T.string)]),
      withTerminationMessagePath(terminationMessagePath): { terminationMessagePath: terminationMessagePath },
      '#withTerminationMessagePolicy':: d.fn(help='', args=[d.arg(name='terminationMessagePolicy', type=d.T.string)]),
      withTerminationMessagePolicy(terminationMessagePolicy): { terminationMessagePolicy: terminationMessagePolicy },
      '#withTty':: d.fn(help='', args=[d.arg(name='tty', type=d.T.boolean)]),
      withTty(tty): { tty: tty },
      '#withVolumeDevices':: d.fn(help='', args=[d.arg(name='volumeDevices', type=d.T.array)]),
      withVolumeDevices(volumeDevices): { volumeDevices: if std.isArray(v=volumeDevices) then volumeDevices else [volumeDevices] },
      '#withVolumeDevicesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeDevices', type=d.T.array)]),
      withVolumeDevicesMixin(volumeDevices): { volumeDevices+: if std.isArray(v=volumeDevices) then volumeDevices else [volumeDevices] },
      '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMounts(volumeMounts): { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] },
      '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMountsMixin(volumeMounts): { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] },
      '#withWorkingDir':: d.fn(help='', args=[d.arg(name='workingDir', type=d.T.string)]),
      withWorkingDir(workingDir): { workingDir: workingDir },
    },
    '#kes':: d.obj(help=''),
    kes: {
      '#affinity':: d.obj(help=''),
      affinity: {
        '#nodeAffinity':: d.obj(help=''),
        nodeAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#preference':: d.obj(help=''),
            preference: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#nodeSelectorTerms':: d.obj(help=''),
            nodeSelectorTerms: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
            },
            '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTerms(nodeSelectorTerms): { spec+: { kes+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
            '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTermsMixin(nodeSelectorTerms): { spec+: { kes+: { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } } } },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAffinity':: d.obj(help=''),
        podAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#namespaceSelector':: d.obj(help=''),
              namespaceSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { namespaceSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { namespaceSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { namespaceSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { namespaceSelector+: { matchLabels+: matchLabels } } },
              },
              '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
              withMatchLabelKeys(matchLabelKeys): { podAffinityTerm+: { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] } },
              '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
              withMatchLabelKeysMixin(matchLabelKeys): { podAffinityTerm+: { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] } },
              '#withMismatchLabelKeys':: d.fn(help='', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
              withMismatchLabelKeys(mismatchLabelKeys): { podAffinityTerm+: { mismatchLabelKeys: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] } },
              '#withMismatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
              withMismatchLabelKeysMixin(mismatchLabelKeys): { podAffinityTerm+: { mismatchLabelKeys+: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] } },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#namespaceSelector':: d.obj(help=''),
            namespaceSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { namespaceSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { namespaceSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { namespaceSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { namespaceSelector+: { matchLabels+: matchLabels } },
            },
            '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
            withMatchLabelKeys(matchLabelKeys): { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
            '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
            withMatchLabelKeysMixin(matchLabelKeys): { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
            '#withMismatchLabelKeys':: d.fn(help='', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
            withMismatchLabelKeys(mismatchLabelKeys): { mismatchLabelKeys: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] },
            '#withMismatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
            withMismatchLabelKeysMixin(mismatchLabelKeys): { mismatchLabelKeys+: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
        '#podAntiAffinity':: d.obj(help=''),
        podAntiAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#namespaceSelector':: d.obj(help=''),
              namespaceSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { namespaceSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { namespaceSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { namespaceSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { namespaceSelector+: { matchLabels+: matchLabels } } },
              },
              '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
              withMatchLabelKeys(matchLabelKeys): { podAffinityTerm+: { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] } },
              '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
              withMatchLabelKeysMixin(matchLabelKeys): { podAffinityTerm+: { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] } },
              '#withMismatchLabelKeys':: d.fn(help='', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
              withMismatchLabelKeys(mismatchLabelKeys): { podAffinityTerm+: { mismatchLabelKeys: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] } },
              '#withMismatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
              withMismatchLabelKeysMixin(mismatchLabelKeys): { podAffinityTerm+: { mismatchLabelKeys+: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] } },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#namespaceSelector':: d.obj(help=''),
            namespaceSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { namespaceSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { namespaceSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { namespaceSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { namespaceSelector+: { matchLabels+: matchLabels } },
            },
            '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
            withMatchLabelKeys(matchLabelKeys): { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
            '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
            withMatchLabelKeysMixin(matchLabelKeys): { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
            '#withMismatchLabelKeys':: d.fn(help='', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
            withMismatchLabelKeys(mismatchLabelKeys): { mismatchLabelKeys: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] },
            '#withMismatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
            withMismatchLabelKeysMixin(mismatchLabelKeys): { mismatchLabelKeys+: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { spec+: { kes+: { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } } } },
        },
      },
      '#clientCertSecret':: d.obj(help=''),
      clientCertSecret: {
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { kes+: { clientCertSecret+: { name: name } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { kes+: { clientCertSecret+: { type: type } } } },
      },
      '#containerSecurityContext':: d.obj(help=''),
      containerSecurityContext: {
        '#appArmorProfile':: d.obj(help=''),
        appArmorProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { kes+: { containerSecurityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { kes+: { containerSecurityContext+: { appArmorProfile+: { type: type } } } } },
        },
        '#capabilities':: d.obj(help=''),
        capabilities: {
          '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
          withAdd(add): { spec+: { kes+: { containerSecurityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } } },
          '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
          withAddMixin(add): { spec+: { kes+: { containerSecurityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } } },
          '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
          withDrop(drop): { spec+: { kes+: { containerSecurityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } } },
          '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
          withDropMixin(drop): { spec+: { kes+: { containerSecurityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } } },
        },
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { kes+: { containerSecurityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { kes+: { containerSecurityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { kes+: { containerSecurityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { kes+: { containerSecurityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { kes+: { containerSecurityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { kes+: { containerSecurityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { kes+: { containerSecurityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { kes+: { containerSecurityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
          withHostProcess(hostProcess): { spec+: { kes+: { containerSecurityContext+: { windowsOptions+: { hostProcess: hostProcess } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { kes+: { containerSecurityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
        withAllowPrivilegeEscalation(allowPrivilegeEscalation): { spec+: { kes+: { containerSecurityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } } },
        '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
        withPrivileged(privileged): { spec+: { kes+: { containerSecurityContext+: { privileged: privileged } } } },
        '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
        withProcMount(procMount): { spec+: { kes+: { containerSecurityContext+: { procMount: procMount } } } },
        '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
        withReadOnlyRootFilesystem(readOnlyRootFilesystem): { spec+: { kes+: { containerSecurityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { kes+: { containerSecurityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { kes+: { containerSecurityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { kes+: { containerSecurityContext+: { runAsUser: runAsUser } } } },
      },
      '#env':: d.obj(help=''),
      env: {
        '#valueFrom':: d.obj(help=''),
        valueFrom: {
          '#configMapKeyRef':: d.obj(help=''),
          configMapKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
          },
          '#fieldRef':: d.obj(help=''),
          fieldRef: {
            '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
            '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
          },
          '#resourceFieldRef':: d.obj(help=''),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
            '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
            '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
          },
          '#secretKeyRef':: d.obj(help=''),
          secretKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
          },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#externalCertSecret':: d.obj(help=''),
      externalCertSecret: {
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { kes+: { externalCertSecret+: { name: name } } } },
        '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { kes+: { externalCertSecret+: { type: type } } } },
      },
      '#kesSecret':: d.obj(help=''),
      kesSecret: {
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { kes+: { kesSecret+: { name: name } } } },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#claims':: d.obj(help=''),
        claims: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#withClaims':: d.fn(help='', args=[d.arg(name='claims', type=d.T.array)]),
        withClaims(claims): { spec+: { kes+: { resources+: { claims: if std.isArray(v=claims) then claims else [claims] } } } },
        '#withClaimsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='claims', type=d.T.array)]),
        withClaimsMixin(claims): { spec+: { kes+: { resources+: { claims+: if std.isArray(v=claims) then claims else [claims] } } } },
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { spec+: { kes+: { resources+: { limits: limits } } } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { spec+: { kes+: { resources+: { limits+: limits } } } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { spec+: { kes+: { resources+: { requests: requests } } } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { spec+: { kes+: { resources+: { requests+: requests } } } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#appArmorProfile':: d.obj(help=''),
        appArmorProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { kes+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { kes+: { securityContext+: { appArmorProfile+: { type: type } } } } },
        },
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { kes+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { kes+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { kes+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { kes+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { kes+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { kes+: { securityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#sysctls':: d.obj(help=''),
        sysctls: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { kes+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { kes+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
          withHostProcess(hostProcess): { spec+: { kes+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { kes+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
        withFsGroup(fsGroup): { spec+: { kes+: { securityContext+: { fsGroup: fsGroup } } } },
        '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
        withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { kes+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { kes+: { securityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { kes+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { kes+: { securityContext+: { runAsUser: runAsUser } } } },
        '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroups(supplementalGroups): { spec+: { kes+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroupsMixin(supplementalGroups): { spec+: { kes+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctls(sysctls): { spec+: { kes+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
        '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctlsMixin(sysctls): { spec+: { kes+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
      },
      '#tolerations':: d.obj(help=''),
      tolerations: {
        '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
        withEffect(effect): { effect: effect },
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
        withOperator(operator): { operator: operator },
        '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
        withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#topologySpreadConstraints':: d.obj(help=''),
      topologySpreadConstraints: {
        '#labelSelector':: d.obj(help=''),
        labelSelector: {
          '#matchExpressions':: d.obj(help=''),
          matchExpressions: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
            withOperator(operator): { operator: operator },
            '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
            withValues(values): { values: if std.isArray(v=values) then values else [values] },
            '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
            withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
          },
          '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
          withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
          '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
          withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
          '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
          '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
        },
        '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
        withMatchLabelKeys(matchLabelKeys): { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
        '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
        withMatchLabelKeysMixin(matchLabelKeys): { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
        '#withMaxSkew':: d.fn(help='', args=[d.arg(name='maxSkew', type=d.T.integer)]),
        withMaxSkew(maxSkew): { maxSkew: maxSkew },
        '#withMinDomains':: d.fn(help='', args=[d.arg(name='minDomains', type=d.T.integer)]),
        withMinDomains(minDomains): { minDomains: minDomains },
        '#withNodeAffinityPolicy':: d.fn(help='', args=[d.arg(name='nodeAffinityPolicy', type=d.T.string)]),
        withNodeAffinityPolicy(nodeAffinityPolicy): { nodeAffinityPolicy: nodeAffinityPolicy },
        '#withNodeTaintsPolicy':: d.fn(help='', args=[d.arg(name='nodeTaintsPolicy', type=d.T.string)]),
        withNodeTaintsPolicy(nodeTaintsPolicy): { nodeTaintsPolicy: nodeTaintsPolicy },
        '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
        withTopologyKey(topologyKey): { topologyKey: topologyKey },
        '#withWhenUnsatisfiable':: d.fn(help='', args=[d.arg(name='whenUnsatisfiable', type=d.T.string)]),
        withWhenUnsatisfiable(whenUnsatisfiable): { whenUnsatisfiable: whenUnsatisfiable },
      },
      '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { kes+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { kes+: { annotations+: annotations } } },
      '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
      withEnv(env): { spec+: { kes+: { env: if std.isArray(v=env) then env else [env] } } },
      '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
      withEnvMixin(env): { spec+: { kes+: { env+: if std.isArray(v=env) then env else [env] } } },
      '#withGcpCredentialSecretName':: d.fn(help='', args=[d.arg(name='gcpCredentialSecretName', type=d.T.string)]),
      withGcpCredentialSecretName(gcpCredentialSecretName): { spec+: { kes+: { gcpCredentialSecretName: gcpCredentialSecretName } } },
      '#withGcpWorkloadIdentityPool':: d.fn(help='', args=[d.arg(name='gcpWorkloadIdentityPool', type=d.T.string)]),
      withGcpWorkloadIdentityPool(gcpWorkloadIdentityPool): { spec+: { kes+: { gcpWorkloadIdentityPool: gcpWorkloadIdentityPool } } },
      '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
      withImage(image): { spec+: { kes+: { image: image } } },
      '#withImagePullPolicy':: d.fn(help='', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
      withImagePullPolicy(imagePullPolicy): { spec+: { kes+: { imagePullPolicy: imagePullPolicy } } },
      '#withKeyName':: d.fn(help='', args=[d.arg(name='keyName', type=d.T.string)]),
      withKeyName(keyName): { spec+: { kes+: { keyName: keyName } } },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { kes+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { kes+: { labels+: labels } } },
      '#withNodeSelector':: d.fn(help='', args=[d.arg(name='nodeSelector', type=d.T.object)]),
      withNodeSelector(nodeSelector): { spec+: { kes+: { nodeSelector: nodeSelector } } },
      '#withNodeSelectorMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelector', type=d.T.object)]),
      withNodeSelectorMixin(nodeSelector): { spec+: { kes+: { nodeSelector+: nodeSelector } } },
      '#withReplicas':: d.fn(help='', args=[d.arg(name='replicas', type=d.T.integer)]),
      withReplicas(replicas): { spec+: { kes+: { replicas: replicas } } },
      '#withServiceAccountName':: d.fn(help='', args=[d.arg(name='serviceAccountName', type=d.T.string)]),
      withServiceAccountName(serviceAccountName): { spec+: { kes+: { serviceAccountName: serviceAccountName } } },
      '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerations(tolerations): { spec+: { kes+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerationsMixin(tolerations): { spec+: { kes+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTopologySpreadConstraints':: d.fn(help='', args=[d.arg(name='topologySpreadConstraints', type=d.T.array)]),
      withTopologySpreadConstraints(topologySpreadConstraints): { spec+: { kes+: { topologySpreadConstraints: if std.isArray(v=topologySpreadConstraints) then topologySpreadConstraints else [topologySpreadConstraints] } } },
      '#withTopologySpreadConstraintsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='topologySpreadConstraints', type=d.T.array)]),
      withTopologySpreadConstraintsMixin(topologySpreadConstraints): { spec+: { kes+: { topologySpreadConstraints+: if std.isArray(v=topologySpreadConstraints) then topologySpreadConstraints else [topologySpreadConstraints] } } },
    },
    '#lifecycle':: d.obj(help=''),
    lifecycle: {
      '#postStart':: d.obj(help=''),
      postStart: {
        '#exec':: d.obj(help=''),
        exec: {
          '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
          withCommand(command): { spec+: { lifecycle+: { postStart+: { exec+: { command: if std.isArray(v=command) then command else [command] } } } } },
          '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
          withCommandMixin(command): { spec+: { lifecycle+: { postStart+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } } } },
        },
        '#httpGet':: d.obj(help=''),
        httpGet: {
          '#httpHeaders':: d.obj(help=''),
          httpHeaders: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { spec+: { lifecycle+: { postStart+: { httpGet+: { host: host } } } } },
          '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeaders(httpHeaders): { spec+: { lifecycle+: { postStart+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } } },
          '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeadersMixin(httpHeaders): { spec+: { lifecycle+: { postStart+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { spec+: { lifecycle+: { postStart+: { httpGet+: { path: path } } } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { spec+: { lifecycle+: { postStart+: { httpGet+: { port: port } } } } },
          '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
          withScheme(scheme): { spec+: { lifecycle+: { postStart+: { httpGet+: { scheme: scheme } } } } },
        },
        '#sleep':: d.obj(help=''),
        sleep: {
          '#withSeconds':: d.fn(help='', args=[d.arg(name='seconds', type=d.T.integer)]),
          withSeconds(seconds): { spec+: { lifecycle+: { postStart+: { sleep+: { seconds: seconds } } } } },
        },
        '#tcpSocket':: d.obj(help=''),
        tcpSocket: {
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { spec+: { lifecycle+: { postStart+: { tcpSocket+: { host: host } } } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { spec+: { lifecycle+: { postStart+: { tcpSocket+: { port: port } } } } },
        },
      },
      '#preStop':: d.obj(help=''),
      preStop: {
        '#exec':: d.obj(help=''),
        exec: {
          '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
          withCommand(command): { spec+: { lifecycle+: { preStop+: { exec+: { command: if std.isArray(v=command) then command else [command] } } } } },
          '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
          withCommandMixin(command): { spec+: { lifecycle+: { preStop+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } } } },
        },
        '#httpGet':: d.obj(help=''),
        httpGet: {
          '#httpHeaders':: d.obj(help=''),
          httpHeaders: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { spec+: { lifecycle+: { preStop+: { httpGet+: { host: host } } } } },
          '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeaders(httpHeaders): { spec+: { lifecycle+: { preStop+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } } },
          '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
          withHttpHeadersMixin(httpHeaders): { spec+: { lifecycle+: { preStop+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { spec+: { lifecycle+: { preStop+: { httpGet+: { path: path } } } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { spec+: { lifecycle+: { preStop+: { httpGet+: { port: port } } } } },
          '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
          withScheme(scheme): { spec+: { lifecycle+: { preStop+: { httpGet+: { scheme: scheme } } } } },
        },
        '#sleep':: d.obj(help=''),
        sleep: {
          '#withSeconds':: d.fn(help='', args=[d.arg(name='seconds', type=d.T.integer)]),
          withSeconds(seconds): { spec+: { lifecycle+: { preStop+: { sleep+: { seconds: seconds } } } } },
        },
        '#tcpSocket':: d.obj(help=''),
        tcpSocket: {
          '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
          withHost(host): { spec+: { lifecycle+: { preStop+: { tcpSocket+: { host: host } } } } },
          '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
          withPort(port): { spec+: { lifecycle+: { preStop+: { tcpSocket+: { port: port } } } } },
        },
      },
    },
    '#liveness':: d.obj(help=''),
    liveness: {
      '#exec':: d.obj(help=''),
      exec: {
        '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { spec+: { liveness+: { exec+: { command: if std.isArray(v=command) then command else [command] } } } },
        '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { spec+: { liveness+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } } },
      },
      '#grpc':: d.obj(help=''),
      grpc: {
        '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.integer)]),
        withPort(port): { spec+: { liveness+: { grpc+: { port: port } } } },
        '#withService':: d.fn(help='', args=[d.arg(name='service', type=d.T.string)]),
        withService(service): { spec+: { liveness+: { grpc+: { service: service } } } },
      },
      '#httpGet':: d.obj(help=''),
      httpGet: {
        '#httpHeaders':: d.obj(help=''),
        httpHeaders: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
        withHost(host): { spec+: { liveness+: { httpGet+: { host: host } } } },
        '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
        withHttpHeaders(httpHeaders): { spec+: { liveness+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
        '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
        withHttpHeadersMixin(httpHeaders): { spec+: { liveness+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { spec+: { liveness+: { httpGet+: { path: path } } } },
        '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
        withPort(port): { spec+: { liveness+: { httpGet+: { port: port } } } },
        '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
        withScheme(scheme): { spec+: { liveness+: { httpGet+: { scheme: scheme } } } },
      },
      '#tcpSocket':: d.obj(help=''),
      tcpSocket: {
        '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
        withHost(host): { spec+: { liveness+: { tcpSocket+: { host: host } } } },
        '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
        withPort(port): { spec+: { liveness+: { tcpSocket+: { port: port } } } },
      },
      '#withFailureThreshold':: d.fn(help='', args=[d.arg(name='failureThreshold', type=d.T.integer)]),
      withFailureThreshold(failureThreshold): { spec+: { liveness+: { failureThreshold: failureThreshold } } },
      '#withInitialDelaySeconds':: d.fn(help='', args=[d.arg(name='initialDelaySeconds', type=d.T.integer)]),
      withInitialDelaySeconds(initialDelaySeconds): { spec+: { liveness+: { initialDelaySeconds: initialDelaySeconds } } },
      '#withPeriodSeconds':: d.fn(help='', args=[d.arg(name='periodSeconds', type=d.T.integer)]),
      withPeriodSeconds(periodSeconds): { spec+: { liveness+: { periodSeconds: periodSeconds } } },
      '#withSuccessThreshold':: d.fn(help='', args=[d.arg(name='successThreshold', type=d.T.integer)]),
      withSuccessThreshold(successThreshold): { spec+: { liveness+: { successThreshold: successThreshold } } },
      '#withTerminationGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='terminationGracePeriodSeconds', type=d.T.integer)]),
      withTerminationGracePeriodSeconds(terminationGracePeriodSeconds): { spec+: { liveness+: { terminationGracePeriodSeconds: terminationGracePeriodSeconds } } },
      '#withTimeoutSeconds':: d.fn(help='', args=[d.arg(name='timeoutSeconds', type=d.T.integer)]),
      withTimeoutSeconds(timeoutSeconds): { spec+: { liveness+: { timeoutSeconds: timeoutSeconds } } },
    },
    '#logging':: d.obj(help=''),
    logging: {
      '#withAnonymous':: d.fn(help='', args=[d.arg(name='anonymous', type=d.T.boolean)]),
      withAnonymous(anonymous): { spec+: { logging+: { anonymous: anonymous } } },
      '#withJson':: d.fn(help='', args=[d.arg(name='json', type=d.T.boolean)]),
      withJson(json): { spec+: { logging+: { json: json } } },
      '#withQuiet':: d.fn(help='', args=[d.arg(name='quiet', type=d.T.boolean)]),
      withQuiet(quiet): { spec+: { logging+: { quiet: quiet } } },
    },
    '#pools':: d.obj(help=''),
    pools: {
      '#affinity':: d.obj(help=''),
      affinity: {
        '#nodeAffinity':: d.obj(help=''),
        nodeAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#preference':: d.obj(help=''),
            preference: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { preference+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { preference+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { preference+: { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { preference+: { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#nodeSelectorTerms':: d.obj(help=''),
            nodeSelectorTerms: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#matchFields':: d.obj(help=''),
              matchFields: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] },
              '#withMatchFields':: d.fn(help='', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFields(matchFields): { matchFields: if std.isArray(v=matchFields) then matchFields else [matchFields] },
              '#withMatchFieldsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchFields', type=d.T.array)]),
              withMatchFieldsMixin(matchFields): { matchFields+: if std.isArray(v=matchFields) then matchFields else [matchFields] },
            },
            '#withNodeSelectorTerms':: d.fn(help='', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTerms(nodeSelectorTerms): { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } },
            '#withNodeSelectorTermsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelectorTerms', type=d.T.array)]),
            withNodeSelectorTermsMixin(nodeSelectorTerms): { affinity+: { nodeAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: { nodeSelectorTerms+: if std.isArray(v=nodeSelectorTerms) then nodeSelectorTerms else [nodeSelectorTerms] } } } },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { affinity+: { nodeAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } },
        },
        '#podAffinity':: d.obj(help=''),
        podAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#namespaceSelector':: d.obj(help=''),
              namespaceSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { namespaceSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { namespaceSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { namespaceSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { namespaceSelector+: { matchLabels+: matchLabels } } },
              },
              '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
              withMatchLabelKeys(matchLabelKeys): { podAffinityTerm+: { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] } },
              '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
              withMatchLabelKeysMixin(matchLabelKeys): { podAffinityTerm+: { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] } },
              '#withMismatchLabelKeys':: d.fn(help='', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
              withMismatchLabelKeys(mismatchLabelKeys): { podAffinityTerm+: { mismatchLabelKeys: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] } },
              '#withMismatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
              withMismatchLabelKeysMixin(mismatchLabelKeys): { podAffinityTerm+: { mismatchLabelKeys+: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] } },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#namespaceSelector':: d.obj(help=''),
            namespaceSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { namespaceSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { namespaceSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { namespaceSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { namespaceSelector+: { matchLabels+: matchLabels } },
            },
            '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
            withMatchLabelKeys(matchLabelKeys): { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
            '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
            withMatchLabelKeysMixin(matchLabelKeys): { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
            '#withMismatchLabelKeys':: d.fn(help='', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
            withMismatchLabelKeys(mismatchLabelKeys): { mismatchLabelKeys: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] },
            '#withMismatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
            withMismatchLabelKeysMixin(mismatchLabelKeys): { mismatchLabelKeys+: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { affinity+: { podAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { affinity+: { podAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } },
        },
        '#podAntiAffinity':: d.obj(help=''),
        podAntiAffinity: {
          '#preferredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          preferredDuringSchedulingIgnoredDuringExecution: {
            '#podAffinityTerm':: d.obj(help=''),
            podAffinityTerm: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#namespaceSelector':: d.obj(help=''),
              namespaceSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { podAffinityTerm+: { namespaceSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { podAffinityTerm+: { namespaceSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { podAffinityTerm+: { namespaceSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { podAffinityTerm+: { namespaceSelector+: { matchLabels+: matchLabels } } },
              },
              '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
              withMatchLabelKeys(matchLabelKeys): { podAffinityTerm+: { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] } },
              '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
              withMatchLabelKeysMixin(matchLabelKeys): { podAffinityTerm+: { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] } },
              '#withMismatchLabelKeys':: d.fn(help='', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
              withMismatchLabelKeys(mismatchLabelKeys): { podAffinityTerm+: { mismatchLabelKeys: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] } },
              '#withMismatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
              withMismatchLabelKeysMixin(mismatchLabelKeys): { podAffinityTerm+: { mismatchLabelKeys+: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] } },
              '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespaces(namespaces): { podAffinityTerm+: { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
              withNamespacesMixin(namespaces): { podAffinityTerm+: { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] } },
              '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
              withTopologyKey(topologyKey): { podAffinityTerm+: { topologyKey: topologyKey } },
            },
            '#withWeight':: d.fn(help='', args=[d.arg(name='weight', type=d.T.integer)]),
            withWeight(weight): { weight: weight },
          },
          '#requiredDuringSchedulingIgnoredDuringExecution':: d.obj(help=''),
          requiredDuringSchedulingIgnoredDuringExecution: {
            '#labelSelector':: d.obj(help=''),
            labelSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
            },
            '#namespaceSelector':: d.obj(help=''),
            namespaceSelector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { namespaceSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { namespaceSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { namespaceSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { namespaceSelector+: { matchLabels+: matchLabels } },
            },
            '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
            withMatchLabelKeys(matchLabelKeys): { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
            '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
            withMatchLabelKeysMixin(matchLabelKeys): { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
            '#withMismatchLabelKeys':: d.fn(help='', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
            withMismatchLabelKeys(mismatchLabelKeys): { mismatchLabelKeys: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] },
            '#withMismatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mismatchLabelKeys', type=d.T.array)]),
            withMismatchLabelKeysMixin(mismatchLabelKeys): { mismatchLabelKeys+: if std.isArray(v=mismatchLabelKeys) then mismatchLabelKeys else [mismatchLabelKeys] },
            '#withNamespaces':: d.fn(help='', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespaces(namespaces): { namespaces: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withNamespacesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='namespaces', type=d.T.array)]),
            withNamespacesMixin(namespaces): { namespaces+: if std.isArray(v=namespaces) then namespaces else [namespaces] },
            '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
            withTopologyKey(topologyKey): { topologyKey: topologyKey },
          },
          '#withPreferredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution): { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } },
          '#withPreferredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='preferredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withPreferredDuringSchedulingIgnoredDuringExecutionMixin(preferredDuringSchedulingIgnoredDuringExecution): { affinity+: { podAntiAffinity+: { preferredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=preferredDuringSchedulingIgnoredDuringExecution) then preferredDuringSchedulingIgnoredDuringExecution else [preferredDuringSchedulingIgnoredDuringExecution] } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecution':: d.fn(help='', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution): { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } },
          '#withRequiredDuringSchedulingIgnoredDuringExecutionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requiredDuringSchedulingIgnoredDuringExecution', type=d.T.array)]),
          withRequiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution): { affinity+: { podAntiAffinity+: { requiredDuringSchedulingIgnoredDuringExecution+: if std.isArray(v=requiredDuringSchedulingIgnoredDuringExecution) then requiredDuringSchedulingIgnoredDuringExecution else [requiredDuringSchedulingIgnoredDuringExecution] } } },
        },
      },
      '#containerSecurityContext':: d.obj(help=''),
      containerSecurityContext: {
        '#appArmorProfile':: d.obj(help=''),
        appArmorProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { containerSecurityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { containerSecurityContext+: { appArmorProfile+: { type: type } } },
        },
        '#capabilities':: d.obj(help=''),
        capabilities: {
          '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
          withAdd(add): { containerSecurityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } },
          '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
          withAddMixin(add): { containerSecurityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } },
          '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
          withDrop(drop): { containerSecurityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } },
          '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
          withDropMixin(drop): { containerSecurityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } },
        },
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { containerSecurityContext+: { seLinuxOptions+: { level: level } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { containerSecurityContext+: { seLinuxOptions+: { role: role } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { containerSecurityContext+: { seLinuxOptions+: { type: type } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { containerSecurityContext+: { seLinuxOptions+: { user: user } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { containerSecurityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { containerSecurityContext+: { seccompProfile+: { type: type } } },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { containerSecurityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { containerSecurityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } },
          '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
          withHostProcess(hostProcess): { containerSecurityContext+: { windowsOptions+: { hostProcess: hostProcess } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { containerSecurityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } },
        },
        '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
        withAllowPrivilegeEscalation(allowPrivilegeEscalation): { containerSecurityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } },
        '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
        withPrivileged(privileged): { containerSecurityContext+: { privileged: privileged } },
        '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
        withProcMount(procMount): { containerSecurityContext+: { procMount: procMount } },
        '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
        withReadOnlyRootFilesystem(readOnlyRootFilesystem): { containerSecurityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { containerSecurityContext+: { runAsGroup: runAsGroup } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { containerSecurityContext+: { runAsNonRoot: runAsNonRoot } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { containerSecurityContext+: { runAsUser: runAsUser } },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#claims':: d.obj(help=''),
        claims: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#withClaims':: d.fn(help='', args=[d.arg(name='claims', type=d.T.array)]),
        withClaims(claims): { resources+: { claims: if std.isArray(v=claims) then claims else [claims] } },
        '#withClaimsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='claims', type=d.T.array)]),
        withClaimsMixin(claims): { resources+: { claims+: if std.isArray(v=claims) then claims else [claims] } },
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { resources+: { limits: limits } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { resources+: { limits+: limits } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { resources+: { requests: requests } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { resources+: { requests+: requests } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#appArmorProfile':: d.obj(help=''),
        appArmorProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { securityContext+: { appArmorProfile+: { type: type } } },
        },
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { securityContext+: { seLinuxOptions+: { level: level } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { securityContext+: { seLinuxOptions+: { role: role } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { securityContext+: { seLinuxOptions+: { type: type } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { securityContext+: { seLinuxOptions+: { user: user } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { securityContext+: { seccompProfile+: { type: type } } },
        },
        '#sysctls':: d.obj(help=''),
        sysctls: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } },
          '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
          withHostProcess(hostProcess): { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } },
        },
        '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
        withFsGroup(fsGroup): { securityContext+: { fsGroup: fsGroup } },
        '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
        withFsGroupChangePolicy(fsGroupChangePolicy): { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { securityContext+: { runAsGroup: runAsGroup } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { securityContext+: { runAsNonRoot: runAsNonRoot } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { securityContext+: { runAsUser: runAsUser } },
        '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroups(supplementalGroups): { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } },
        '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroupsMixin(supplementalGroups): { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } },
        '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctls(sysctls): { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } },
        '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctlsMixin(sysctls): { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } },
      },
      '#tolerations':: d.obj(help=''),
      tolerations: {
        '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
        withEffect(effect): { effect: effect },
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
        withOperator(operator): { operator: operator },
        '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
        withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#topologySpreadConstraints':: d.obj(help=''),
      topologySpreadConstraints: {
        '#labelSelector':: d.obj(help=''),
        labelSelector: {
          '#matchExpressions':: d.obj(help=''),
          matchExpressions: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
            withOperator(operator): { operator: operator },
            '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
            withValues(values): { values: if std.isArray(v=values) then values else [values] },
            '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
            withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
          },
          '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
          withMatchExpressions(matchExpressions): { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
          '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
          withMatchExpressionsMixin(matchExpressions): { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
          '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { labelSelector+: { matchLabels: matchLabels } },
          '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { labelSelector+: { matchLabels+: matchLabels } },
        },
        '#withMatchLabelKeys':: d.fn(help='', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
        withMatchLabelKeys(matchLabelKeys): { matchLabelKeys: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
        '#withMatchLabelKeysMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabelKeys', type=d.T.array)]),
        withMatchLabelKeysMixin(matchLabelKeys): { matchLabelKeys+: if std.isArray(v=matchLabelKeys) then matchLabelKeys else [matchLabelKeys] },
        '#withMaxSkew':: d.fn(help='', args=[d.arg(name='maxSkew', type=d.T.integer)]),
        withMaxSkew(maxSkew): { maxSkew: maxSkew },
        '#withMinDomains':: d.fn(help='', args=[d.arg(name='minDomains', type=d.T.integer)]),
        withMinDomains(minDomains): { minDomains: minDomains },
        '#withNodeAffinityPolicy':: d.fn(help='', args=[d.arg(name='nodeAffinityPolicy', type=d.T.string)]),
        withNodeAffinityPolicy(nodeAffinityPolicy): { nodeAffinityPolicy: nodeAffinityPolicy },
        '#withNodeTaintsPolicy':: d.fn(help='', args=[d.arg(name='nodeTaintsPolicy', type=d.T.string)]),
        withNodeTaintsPolicy(nodeTaintsPolicy): { nodeTaintsPolicy: nodeTaintsPolicy },
        '#withTopologyKey':: d.fn(help='', args=[d.arg(name='topologyKey', type=d.T.string)]),
        withTopologyKey(topologyKey): { topologyKey: topologyKey },
        '#withWhenUnsatisfiable':: d.fn(help='', args=[d.arg(name='whenUnsatisfiable', type=d.T.string)]),
        withWhenUnsatisfiable(whenUnsatisfiable): { whenUnsatisfiable: whenUnsatisfiable },
      },
      '#volumeClaimTemplate':: d.obj(help=''),
      volumeClaimTemplate: {
        '#metadata':: d.obj(help=''),
        metadata: {
          '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
          withAnnotations(annotations): { volumeClaimTemplate+: { metadata+: { annotations: annotations } } },
          '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
          withAnnotationsMixin(annotations): { volumeClaimTemplate+: { metadata+: { annotations+: annotations } } },
          '#withFinalizers':: d.fn(help='', args=[d.arg(name='finalizers', type=d.T.array)]),
          withFinalizers(finalizers): { volumeClaimTemplate+: { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } } },
          '#withFinalizersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
          withFinalizersMixin(finalizers): { volumeClaimTemplate+: { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } } },
          '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
          withLabels(labels): { volumeClaimTemplate+: { metadata+: { labels: labels } } },
          '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
          withLabelsMixin(labels): { volumeClaimTemplate+: { metadata+: { labels+: labels } } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { volumeClaimTemplate+: { metadata+: { name: name } } },
          '#withNamespace':: d.fn(help='', args=[d.arg(name='namespace', type=d.T.string)]),
          withNamespace(namespace): { volumeClaimTemplate+: { metadata+: { namespace: namespace } } },
        },
        '#spec':: d.obj(help=''),
        spec: {
          '#dataSource':: d.obj(help=''),
          dataSource: {
            '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
            withApiGroup(apiGroup): { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } },
            '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
            withKind(kind): { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } },
          },
          '#dataSourceRef':: d.obj(help=''),
          dataSourceRef: {
            '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
            withApiGroup(apiGroup): { volumeClaimTemplate+: { spec+: { dataSourceRef+: { apiGroup: apiGroup } } } },
            '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
            withKind(kind): { volumeClaimTemplate+: { spec+: { dataSourceRef+: { kind: kind } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { volumeClaimTemplate+: { spec+: { dataSourceRef+: { name: name } } } },
            '#withNamespace':: d.fn(help='', args=[d.arg(name='namespace', type=d.T.string)]),
            withNamespace(namespace): { volumeClaimTemplate+: { spec+: { dataSourceRef+: { namespace: namespace } } } },
          },
          '#resources':: d.obj(help=''),
          resources: {
            '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
            withLimits(limits): { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } },
            '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
            withLimitsMixin(limits): { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } },
            '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
            withRequests(requests): { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } },
            '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
            withRequestsMixin(requests): { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } },
          },
          '#selector':: d.obj(help=''),
          selector: {
            '#matchExpressions':: d.obj(help=''),
            matchExpressions: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressions(matchExpressions): { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } },
            '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressionsMixin(matchExpressions): { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } },
            '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } },
            '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } },
          },
          '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
          withAccessModes(accessModes): { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } },
          '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
          withAccessModesMixin(accessModes): { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } },
          '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
          withStorageClassName(storageClassName): { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } },
          '#withVolumeAttributesClassName':: d.fn(help='', args=[d.arg(name='volumeAttributesClassName', type=d.T.string)]),
          withVolumeAttributesClassName(volumeAttributesClassName): { volumeClaimTemplate+: { spec+: { volumeAttributesClassName: volumeAttributesClassName } } },
          '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
          withVolumeMode(volumeMode): { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } },
        },
        '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
        withApiVersion(apiVersion): { volumeClaimTemplate+: { apiVersion: apiVersion } },
        '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
        withKind(kind): { volumeClaimTemplate+: { kind: kind } },
      },
      '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { annotations: annotations },
      '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { annotations+: annotations },
      '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { labels: labels },
      '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { labels+: labels },
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withNodeSelector':: d.fn(help='', args=[d.arg(name='nodeSelector', type=d.T.object)]),
      withNodeSelector(nodeSelector): { nodeSelector: nodeSelector },
      '#withNodeSelectorMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelector', type=d.T.object)]),
      withNodeSelectorMixin(nodeSelector): { nodeSelector+: nodeSelector },
      '#withRuntimeClassName':: d.fn(help='', args=[d.arg(name='runtimeClassName', type=d.T.string)]),
      withRuntimeClassName(runtimeClassName): { runtimeClassName: runtimeClassName },
      '#withServers':: d.fn(help='', args=[d.arg(name='servers', type=d.T.integer)]),
      withServers(servers): { servers: servers },
      '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerations(tolerations): { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] },
      '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerationsMixin(tolerations): { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] },
      '#withTopologySpreadConstraints':: d.fn(help='', args=[d.arg(name='topologySpreadConstraints', type=d.T.array)]),
      withTopologySpreadConstraints(topologySpreadConstraints): { topologySpreadConstraints: if std.isArray(v=topologySpreadConstraints) then topologySpreadConstraints else [topologySpreadConstraints] },
      '#withTopologySpreadConstraintsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='topologySpreadConstraints', type=d.T.array)]),
      withTopologySpreadConstraintsMixin(topologySpreadConstraints): { topologySpreadConstraints+: if std.isArray(v=topologySpreadConstraints) then topologySpreadConstraints else [topologySpreadConstraints] },
      '#withVolumesPerServer':: d.fn(help='', args=[d.arg(name='volumesPerServer', type=d.T.integer)]),
      withVolumesPerServer(volumesPerServer): { volumesPerServer: volumesPerServer },
    },
    '#readiness':: d.obj(help=''),
    readiness: {
      '#exec':: d.obj(help=''),
      exec: {
        '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { spec+: { readiness+: { exec+: { command: if std.isArray(v=command) then command else [command] } } } },
        '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { spec+: { readiness+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } } },
      },
      '#grpc':: d.obj(help=''),
      grpc: {
        '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.integer)]),
        withPort(port): { spec+: { readiness+: { grpc+: { port: port } } } },
        '#withService':: d.fn(help='', args=[d.arg(name='service', type=d.T.string)]),
        withService(service): { spec+: { readiness+: { grpc+: { service: service } } } },
      },
      '#httpGet':: d.obj(help=''),
      httpGet: {
        '#httpHeaders':: d.obj(help=''),
        httpHeaders: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
        withHost(host): { spec+: { readiness+: { httpGet+: { host: host } } } },
        '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
        withHttpHeaders(httpHeaders): { spec+: { readiness+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
        '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
        withHttpHeadersMixin(httpHeaders): { spec+: { readiness+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { spec+: { readiness+: { httpGet+: { path: path } } } },
        '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
        withPort(port): { spec+: { readiness+: { httpGet+: { port: port } } } },
        '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
        withScheme(scheme): { spec+: { readiness+: { httpGet+: { scheme: scheme } } } },
      },
      '#tcpSocket':: d.obj(help=''),
      tcpSocket: {
        '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
        withHost(host): { spec+: { readiness+: { tcpSocket+: { host: host } } } },
        '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
        withPort(port): { spec+: { readiness+: { tcpSocket+: { port: port } } } },
      },
      '#withFailureThreshold':: d.fn(help='', args=[d.arg(name='failureThreshold', type=d.T.integer)]),
      withFailureThreshold(failureThreshold): { spec+: { readiness+: { failureThreshold: failureThreshold } } },
      '#withInitialDelaySeconds':: d.fn(help='', args=[d.arg(name='initialDelaySeconds', type=d.T.integer)]),
      withInitialDelaySeconds(initialDelaySeconds): { spec+: { readiness+: { initialDelaySeconds: initialDelaySeconds } } },
      '#withPeriodSeconds':: d.fn(help='', args=[d.arg(name='periodSeconds', type=d.T.integer)]),
      withPeriodSeconds(periodSeconds): { spec+: { readiness+: { periodSeconds: periodSeconds } } },
      '#withSuccessThreshold':: d.fn(help='', args=[d.arg(name='successThreshold', type=d.T.integer)]),
      withSuccessThreshold(successThreshold): { spec+: { readiness+: { successThreshold: successThreshold } } },
      '#withTerminationGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='terminationGracePeriodSeconds', type=d.T.integer)]),
      withTerminationGracePeriodSeconds(terminationGracePeriodSeconds): { spec+: { readiness+: { terminationGracePeriodSeconds: terminationGracePeriodSeconds } } },
      '#withTimeoutSeconds':: d.fn(help='', args=[d.arg(name='timeoutSeconds', type=d.T.integer)]),
      withTimeoutSeconds(timeoutSeconds): { spec+: { readiness+: { timeoutSeconds: timeoutSeconds } } },
    },
    '#serviceMetadata':: d.obj(help=''),
    serviceMetadata: {
      '#withConsoleServiceAnnotations':: d.fn(help='', args=[d.arg(name='consoleServiceAnnotations', type=d.T.object)]),
      withConsoleServiceAnnotations(consoleServiceAnnotations): { spec+: { serviceMetadata+: { consoleServiceAnnotations: consoleServiceAnnotations } } },
      '#withConsoleServiceAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='consoleServiceAnnotations', type=d.T.object)]),
      withConsoleServiceAnnotationsMixin(consoleServiceAnnotations): { spec+: { serviceMetadata+: { consoleServiceAnnotations+: consoleServiceAnnotations } } },
      '#withConsoleServiceLabels':: d.fn(help='', args=[d.arg(name='consoleServiceLabels', type=d.T.object)]),
      withConsoleServiceLabels(consoleServiceLabels): { spec+: { serviceMetadata+: { consoleServiceLabels: consoleServiceLabels } } },
      '#withConsoleServiceLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='consoleServiceLabels', type=d.T.object)]),
      withConsoleServiceLabelsMixin(consoleServiceLabels): { spec+: { serviceMetadata+: { consoleServiceLabels+: consoleServiceLabels } } },
      '#withMinioServiceAnnotations':: d.fn(help='', args=[d.arg(name='minioServiceAnnotations', type=d.T.object)]),
      withMinioServiceAnnotations(minioServiceAnnotations): { spec+: { serviceMetadata+: { minioServiceAnnotations: minioServiceAnnotations } } },
      '#withMinioServiceAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='minioServiceAnnotations', type=d.T.object)]),
      withMinioServiceAnnotationsMixin(minioServiceAnnotations): { spec+: { serviceMetadata+: { minioServiceAnnotations+: minioServiceAnnotations } } },
      '#withMinioServiceLabels':: d.fn(help='', args=[d.arg(name='minioServiceLabels', type=d.T.object)]),
      withMinioServiceLabels(minioServiceLabels): { spec+: { serviceMetadata+: { minioServiceLabels: minioServiceLabels } } },
      '#withMinioServiceLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='minioServiceLabels', type=d.T.object)]),
      withMinioServiceLabelsMixin(minioServiceLabels): { spec+: { serviceMetadata+: { minioServiceLabels+: minioServiceLabels } } },
    },
    '#sideCars':: d.obj(help=''),
    sideCars: {
      '#containers':: d.obj(help=''),
      containers: {
        '#env':: d.obj(help=''),
        env: {
          '#valueFrom':: d.obj(help=''),
          valueFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#envFrom':: d.obj(help=''),
        envFrom: {
          '#configMapRef':: d.obj(help=''),
          configMapRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMapRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMapRef+: { optional: optional } },
          },
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { secretRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secretRef+: { optional: optional } },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { prefix: prefix },
        },
        '#lifecycle':: d.obj(help=''),
        lifecycle: {
          '#postStart':: d.obj(help=''),
          postStart: {
            '#exec':: d.obj(help=''),
            exec: {
              '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
              withCommand(command): { lifecycle+: { postStart+: { exec+: { command: if std.isArray(v=command) then command else [command] } } } },
              '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
              withCommandMixin(command): { lifecycle+: { postStart+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } } },
            },
            '#httpGet':: d.obj(help=''),
            httpGet: {
              '#httpHeaders':: d.obj(help=''),
              httpHeaders: {
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { name: name },
                '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
                withValue(value): { value: value },
              },
              '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
              withHost(host): { lifecycle+: { postStart+: { httpGet+: { host: host } } } },
              '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
              withHttpHeaders(httpHeaders): { lifecycle+: { postStart+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
              '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
              withHttpHeadersMixin(httpHeaders): { lifecycle+: { postStart+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { lifecycle+: { postStart+: { httpGet+: { path: path } } } },
              '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
              withPort(port): { lifecycle+: { postStart+: { httpGet+: { port: port } } } },
              '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
              withScheme(scheme): { lifecycle+: { postStart+: { httpGet+: { scheme: scheme } } } },
            },
            '#sleep':: d.obj(help=''),
            sleep: {
              '#withSeconds':: d.fn(help='', args=[d.arg(name='seconds', type=d.T.integer)]),
              withSeconds(seconds): { lifecycle+: { postStart+: { sleep+: { seconds: seconds } } } },
            },
            '#tcpSocket':: d.obj(help=''),
            tcpSocket: {
              '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
              withHost(host): { lifecycle+: { postStart+: { tcpSocket+: { host: host } } } },
              '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
              withPort(port): { lifecycle+: { postStart+: { tcpSocket+: { port: port } } } },
            },
          },
          '#preStop':: d.obj(help=''),
          preStop: {
            '#exec':: d.obj(help=''),
            exec: {
              '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
              withCommand(command): { lifecycle+: { preStop+: { exec+: { command: if std.isArray(v=command) then command else [command] } } } },
              '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
              withCommandMixin(command): { lifecycle+: { preStop+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } } },
            },
            '#httpGet':: d.obj(help=''),
            httpGet: {
              '#httpHeaders':: d.obj(help=''),
              httpHeaders: {
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { name: name },
                '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
                withValue(value): { value: value },
              },
              '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
              withHost(host): { lifecycle+: { preStop+: { httpGet+: { host: host } } } },
              '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
              withHttpHeaders(httpHeaders): { lifecycle+: { preStop+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
              '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
              withHttpHeadersMixin(httpHeaders): { lifecycle+: { preStop+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { lifecycle+: { preStop+: { httpGet+: { path: path } } } },
              '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
              withPort(port): { lifecycle+: { preStop+: { httpGet+: { port: port } } } },
              '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
              withScheme(scheme): { lifecycle+: { preStop+: { httpGet+: { scheme: scheme } } } },
            },
            '#sleep':: d.obj(help=''),
            sleep: {
              '#withSeconds':: d.fn(help='', args=[d.arg(name='seconds', type=d.T.integer)]),
              withSeconds(seconds): { lifecycle+: { preStop+: { sleep+: { seconds: seconds } } } },
            },
            '#tcpSocket':: d.obj(help=''),
            tcpSocket: {
              '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
              withHost(host): { lifecycle+: { preStop+: { tcpSocket+: { host: host } } } },
              '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
              withPort(port): { lifecycle+: { preStop+: { tcpSocket+: { port: port } } } },
            },
          },
        },
        '#livenessProbe':: d.obj(help=''),
        livenessProbe: {
          '#exec':: d.obj(help=''),
          exec: {
            '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
            withCommand(command): { livenessProbe+: { exec+: { command: if std.isArray(v=command) then command else [command] } } },
            '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
            withCommandMixin(command): { livenessProbe+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } },
          },
          '#grpc':: d.obj(help=''),
          grpc: {
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.integer)]),
            withPort(port): { livenessProbe+: { grpc+: { port: port } } },
            '#withService':: d.fn(help='', args=[d.arg(name='service', type=d.T.string)]),
            withService(service): { livenessProbe+: { grpc+: { service: service } } },
          },
          '#httpGet':: d.obj(help=''),
          httpGet: {
            '#httpHeaders':: d.obj(help=''),
            httpHeaders: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { livenessProbe+: { httpGet+: { host: host } } },
            '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeaders(httpHeaders): { livenessProbe+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
            '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeadersMixin(httpHeaders): { livenessProbe+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { livenessProbe+: { httpGet+: { path: path } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { livenessProbe+: { httpGet+: { port: port } } },
            '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
            withScheme(scheme): { livenessProbe+: { httpGet+: { scheme: scheme } } },
          },
          '#tcpSocket':: d.obj(help=''),
          tcpSocket: {
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { livenessProbe+: { tcpSocket+: { host: host } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { livenessProbe+: { tcpSocket+: { port: port } } },
          },
          '#withFailureThreshold':: d.fn(help='', args=[d.arg(name='failureThreshold', type=d.T.integer)]),
          withFailureThreshold(failureThreshold): { livenessProbe+: { failureThreshold: failureThreshold } },
          '#withInitialDelaySeconds':: d.fn(help='', args=[d.arg(name='initialDelaySeconds', type=d.T.integer)]),
          withInitialDelaySeconds(initialDelaySeconds): { livenessProbe+: { initialDelaySeconds: initialDelaySeconds } },
          '#withPeriodSeconds':: d.fn(help='', args=[d.arg(name='periodSeconds', type=d.T.integer)]),
          withPeriodSeconds(periodSeconds): { livenessProbe+: { periodSeconds: periodSeconds } },
          '#withSuccessThreshold':: d.fn(help='', args=[d.arg(name='successThreshold', type=d.T.integer)]),
          withSuccessThreshold(successThreshold): { livenessProbe+: { successThreshold: successThreshold } },
          '#withTerminationGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='terminationGracePeriodSeconds', type=d.T.integer)]),
          withTerminationGracePeriodSeconds(terminationGracePeriodSeconds): { livenessProbe+: { terminationGracePeriodSeconds: terminationGracePeriodSeconds } },
          '#withTimeoutSeconds':: d.fn(help='', args=[d.arg(name='timeoutSeconds', type=d.T.integer)]),
          withTimeoutSeconds(timeoutSeconds): { livenessProbe+: { timeoutSeconds: timeoutSeconds } },
        },
        '#ports':: d.obj(help=''),
        ports: {
          '#withContainerPort':: d.fn(help='', args=[d.arg(name='containerPort', type=d.T.integer)]),
          withContainerPort(containerPort): { containerPort: containerPort },
          '#withHostIP':: d.fn(help='', args=[d.arg(name='hostIP', type=d.T.string)]),
          withHostIP(hostIP): { hostIP: hostIP },
          '#withHostPort':: d.fn(help='', args=[d.arg(name='hostPort', type=d.T.integer)]),
          withHostPort(hostPort): { hostPort: hostPort },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withProtocol':: d.fn(help='', args=[d.arg(name='protocol', type=d.T.string)]),
          withProtocol(protocol): { protocol: protocol },
        },
        '#readinessProbe':: d.obj(help=''),
        readinessProbe: {
          '#exec':: d.obj(help=''),
          exec: {
            '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
            withCommand(command): { readinessProbe+: { exec+: { command: if std.isArray(v=command) then command else [command] } } },
            '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
            withCommandMixin(command): { readinessProbe+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } },
          },
          '#grpc':: d.obj(help=''),
          grpc: {
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.integer)]),
            withPort(port): { readinessProbe+: { grpc+: { port: port } } },
            '#withService':: d.fn(help='', args=[d.arg(name='service', type=d.T.string)]),
            withService(service): { readinessProbe+: { grpc+: { service: service } } },
          },
          '#httpGet':: d.obj(help=''),
          httpGet: {
            '#httpHeaders':: d.obj(help=''),
            httpHeaders: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { readinessProbe+: { httpGet+: { host: host } } },
            '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeaders(httpHeaders): { readinessProbe+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
            '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeadersMixin(httpHeaders): { readinessProbe+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { readinessProbe+: { httpGet+: { path: path } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { readinessProbe+: { httpGet+: { port: port } } },
            '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
            withScheme(scheme): { readinessProbe+: { httpGet+: { scheme: scheme } } },
          },
          '#tcpSocket':: d.obj(help=''),
          tcpSocket: {
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { readinessProbe+: { tcpSocket+: { host: host } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { readinessProbe+: { tcpSocket+: { port: port } } },
          },
          '#withFailureThreshold':: d.fn(help='', args=[d.arg(name='failureThreshold', type=d.T.integer)]),
          withFailureThreshold(failureThreshold): { readinessProbe+: { failureThreshold: failureThreshold } },
          '#withInitialDelaySeconds':: d.fn(help='', args=[d.arg(name='initialDelaySeconds', type=d.T.integer)]),
          withInitialDelaySeconds(initialDelaySeconds): { readinessProbe+: { initialDelaySeconds: initialDelaySeconds } },
          '#withPeriodSeconds':: d.fn(help='', args=[d.arg(name='periodSeconds', type=d.T.integer)]),
          withPeriodSeconds(periodSeconds): { readinessProbe+: { periodSeconds: periodSeconds } },
          '#withSuccessThreshold':: d.fn(help='', args=[d.arg(name='successThreshold', type=d.T.integer)]),
          withSuccessThreshold(successThreshold): { readinessProbe+: { successThreshold: successThreshold } },
          '#withTerminationGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='terminationGracePeriodSeconds', type=d.T.integer)]),
          withTerminationGracePeriodSeconds(terminationGracePeriodSeconds): { readinessProbe+: { terminationGracePeriodSeconds: terminationGracePeriodSeconds } },
          '#withTimeoutSeconds':: d.fn(help='', args=[d.arg(name='timeoutSeconds', type=d.T.integer)]),
          withTimeoutSeconds(timeoutSeconds): { readinessProbe+: { timeoutSeconds: timeoutSeconds } },
        },
        '#resizePolicy':: d.obj(help=''),
        resizePolicy: {
          '#withResourceName':: d.fn(help='', args=[d.arg(name='resourceName', type=d.T.string)]),
          withResourceName(resourceName): { resourceName: resourceName },
          '#withRestartPolicy':: d.fn(help='', args=[d.arg(name='restartPolicy', type=d.T.string)]),
          withRestartPolicy(restartPolicy): { restartPolicy: restartPolicy },
        },
        '#resources':: d.obj(help=''),
        resources: {
          '#claims':: d.obj(help=''),
          claims: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
          },
          '#withClaims':: d.fn(help='', args=[d.arg(name='claims', type=d.T.array)]),
          withClaims(claims): { resources+: { claims: if std.isArray(v=claims) then claims else [claims] } },
          '#withClaimsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='claims', type=d.T.array)]),
          withClaimsMixin(claims): { resources+: { claims+: if std.isArray(v=claims) then claims else [claims] } },
          '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { resources+: { limits: limits } },
          '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { resources+: { limits+: limits } },
          '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { resources+: { requests: requests } },
          '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { resources+: { requests+: requests } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#appArmorProfile':: d.obj(help=''),
          appArmorProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { securityContext+: { appArmorProfile+: { type: type } } },
          },
          '#capabilities':: d.obj(help=''),
          capabilities: {
            '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
            withAdd(add): { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } },
            '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
            withAddMixin(add): { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } },
            '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
            withDrop(drop): { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } },
            '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
            withDropMixin(drop): { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } },
          },
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { securityContext+: { seLinuxOptions+: { level: level } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { securityContext+: { seLinuxOptions+: { role: role } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { securityContext+: { seLinuxOptions+: { type: type } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { securityContext+: { seLinuxOptions+: { user: user } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { securityContext+: { seccompProfile+: { type: type } } },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } },
            '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
            withHostProcess(hostProcess): { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } },
          },
          '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
          withAllowPrivilegeEscalation(allowPrivilegeEscalation): { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } },
          '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
          withPrivileged(privileged): { securityContext+: { privileged: privileged } },
          '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
          withProcMount(procMount): { securityContext+: { procMount: procMount } },
          '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
          withReadOnlyRootFilesystem(readOnlyRootFilesystem): { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { securityContext+: { runAsGroup: runAsGroup } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { securityContext+: { runAsNonRoot: runAsNonRoot } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { securityContext+: { runAsUser: runAsUser } },
        },
        '#startupProbe':: d.obj(help=''),
        startupProbe: {
          '#exec':: d.obj(help=''),
          exec: {
            '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
            withCommand(command): { startupProbe+: { exec+: { command: if std.isArray(v=command) then command else [command] } } },
            '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
            withCommandMixin(command): { startupProbe+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } },
          },
          '#grpc':: d.obj(help=''),
          grpc: {
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.integer)]),
            withPort(port): { startupProbe+: { grpc+: { port: port } } },
            '#withService':: d.fn(help='', args=[d.arg(name='service', type=d.T.string)]),
            withService(service): { startupProbe+: { grpc+: { service: service } } },
          },
          '#httpGet':: d.obj(help=''),
          httpGet: {
            '#httpHeaders':: d.obj(help=''),
            httpHeaders: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
              '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
              withValue(value): { value: value },
            },
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { startupProbe+: { httpGet+: { host: host } } },
            '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeaders(httpHeaders): { startupProbe+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
            '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
            withHttpHeadersMixin(httpHeaders): { startupProbe+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { startupProbe+: { httpGet+: { path: path } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { startupProbe+: { httpGet+: { port: port } } },
            '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
            withScheme(scheme): { startupProbe+: { httpGet+: { scheme: scheme } } },
          },
          '#tcpSocket':: d.obj(help=''),
          tcpSocket: {
            '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { startupProbe+: { tcpSocket+: { host: host } } },
            '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
            withPort(port): { startupProbe+: { tcpSocket+: { port: port } } },
          },
          '#withFailureThreshold':: d.fn(help='', args=[d.arg(name='failureThreshold', type=d.T.integer)]),
          withFailureThreshold(failureThreshold): { startupProbe+: { failureThreshold: failureThreshold } },
          '#withInitialDelaySeconds':: d.fn(help='', args=[d.arg(name='initialDelaySeconds', type=d.T.integer)]),
          withInitialDelaySeconds(initialDelaySeconds): { startupProbe+: { initialDelaySeconds: initialDelaySeconds } },
          '#withPeriodSeconds':: d.fn(help='', args=[d.arg(name='periodSeconds', type=d.T.integer)]),
          withPeriodSeconds(periodSeconds): { startupProbe+: { periodSeconds: periodSeconds } },
          '#withSuccessThreshold':: d.fn(help='', args=[d.arg(name='successThreshold', type=d.T.integer)]),
          withSuccessThreshold(successThreshold): { startupProbe+: { successThreshold: successThreshold } },
          '#withTerminationGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='terminationGracePeriodSeconds', type=d.T.integer)]),
          withTerminationGracePeriodSeconds(terminationGracePeriodSeconds): { startupProbe+: { terminationGracePeriodSeconds: terminationGracePeriodSeconds } },
          '#withTimeoutSeconds':: d.fn(help='', args=[d.arg(name='timeoutSeconds', type=d.T.integer)]),
          withTimeoutSeconds(timeoutSeconds): { startupProbe+: { timeoutSeconds: timeoutSeconds } },
        },
        '#volumeDevices':: d.obj(help=''),
        volumeDevices: {
          '#withDevicePath':: d.fn(help='', args=[d.arg(name='devicePath', type=d.T.string)]),
          withDevicePath(devicePath): { devicePath: devicePath },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
          withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#withArgs':: d.fn(help='', args=[d.arg(name='args', type=d.T.array)]),
        withArgs(args): { args: if std.isArray(v=args) then args else [args] },
        '#withArgsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
        withArgsMixin(args): { args+: if std.isArray(v=args) then args else [args] },
        '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { command: if std.isArray(v=command) then command else [command] },
        '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { command+: if std.isArray(v=command) then command else [command] },
        '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
        withEnv(env): { env: if std.isArray(v=env) then env else [env] },
        '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFrom(envFrom): { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] },
        '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFromMixin(envFrom): { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] },
        '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
        withEnvMixin(env): { env+: if std.isArray(v=env) then env else [env] },
        '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { image: image },
        '#withImagePullPolicy':: d.fn(help='', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
        withImagePullPolicy(imagePullPolicy): { imagePullPolicy: imagePullPolicy },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withPorts':: d.fn(help='', args=[d.arg(name='ports', type=d.T.array)]),
        withPorts(ports): { ports: if std.isArray(v=ports) then ports else [ports] },
        '#withPortsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ports', type=d.T.array)]),
        withPortsMixin(ports): { ports+: if std.isArray(v=ports) then ports else [ports] },
        '#withResizePolicy':: d.fn(help='', args=[d.arg(name='resizePolicy', type=d.T.array)]),
        withResizePolicy(resizePolicy): { resizePolicy: if std.isArray(v=resizePolicy) then resizePolicy else [resizePolicy] },
        '#withResizePolicyMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resizePolicy', type=d.T.array)]),
        withResizePolicyMixin(resizePolicy): { resizePolicy+: if std.isArray(v=resizePolicy) then resizePolicy else [resizePolicy] },
        '#withRestartPolicy':: d.fn(help='', args=[d.arg(name='restartPolicy', type=d.T.string)]),
        withRestartPolicy(restartPolicy): { restartPolicy: restartPolicy },
        '#withStdin':: d.fn(help='', args=[d.arg(name='stdin', type=d.T.boolean)]),
        withStdin(stdin): { stdin: stdin },
        '#withStdinOnce':: d.fn(help='', args=[d.arg(name='stdinOnce', type=d.T.boolean)]),
        withStdinOnce(stdinOnce): { stdinOnce: stdinOnce },
        '#withTerminationMessagePath':: d.fn(help='', args=[d.arg(name='terminationMessagePath', type=d.T.string)]),
        withTerminationMessagePath(terminationMessagePath): { terminationMessagePath: terminationMessagePath },
        '#withTerminationMessagePolicy':: d.fn(help='', args=[d.arg(name='terminationMessagePolicy', type=d.T.string)]),
        withTerminationMessagePolicy(terminationMessagePolicy): { terminationMessagePolicy: terminationMessagePolicy },
        '#withTty':: d.fn(help='', args=[d.arg(name='tty', type=d.T.boolean)]),
        withTty(tty): { tty: tty },
        '#withVolumeDevices':: d.fn(help='', args=[d.arg(name='volumeDevices', type=d.T.array)]),
        withVolumeDevices(volumeDevices): { volumeDevices: if std.isArray(v=volumeDevices) then volumeDevices else [volumeDevices] },
        '#withVolumeDevicesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeDevices', type=d.T.array)]),
        withVolumeDevicesMixin(volumeDevices): { volumeDevices+: if std.isArray(v=volumeDevices) then volumeDevices else [volumeDevices] },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] },
        '#withWorkingDir':: d.fn(help='', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { workingDir: workingDir },
      },
      '#resources':: d.obj(help=''),
      resources: {
        '#claims':: d.obj(help=''),
        claims: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#withClaims':: d.fn(help='', args=[d.arg(name='claims', type=d.T.array)]),
        withClaims(claims): { spec+: { sideCars+: { resources+: { claims: if std.isArray(v=claims) then claims else [claims] } } } },
        '#withClaimsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='claims', type=d.T.array)]),
        withClaimsMixin(claims): { spec+: { sideCars+: { resources+: { claims+: if std.isArray(v=claims) then claims else [claims] } } } },
        '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { spec+: { sideCars+: { resources+: { limits: limits } } } },
        '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { spec+: { sideCars+: { resources+: { limits+: limits } } } },
        '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { spec+: { sideCars+: { resources+: { requests: requests } } } },
        '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { spec+: { sideCars+: { resources+: { requests+: requests } } } },
      },
      '#volumeClaimTemplates':: d.obj(help=''),
      volumeClaimTemplates: {
        '#metadata':: d.obj(help=''),
        metadata: {
          '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
          withAnnotations(annotations): { metadata+: { annotations: annotations } },
          '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
          withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
          '#withFinalizers':: d.fn(help='', args=[d.arg(name='finalizers', type=d.T.array)]),
          withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
          '#withFinalizersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
          withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
          '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
          withLabels(labels): { metadata+: { labels: labels } },
          '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
          withLabelsMixin(labels): { metadata+: { labels+: labels } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { metadata+: { name: name } },
          '#withNamespace':: d.fn(help='', args=[d.arg(name='namespace', type=d.T.string)]),
          withNamespace(namespace): { metadata+: { namespace: namespace } },
        },
        '#spec':: d.obj(help=''),
        spec: {
          '#dataSource':: d.obj(help=''),
          dataSource: {
            '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
            withApiGroup(apiGroup): { spec+: { dataSource+: { apiGroup: apiGroup } } },
            '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
            withKind(kind): { spec+: { dataSource+: { kind: kind } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { dataSource+: { name: name } } },
          },
          '#dataSourceRef':: d.obj(help=''),
          dataSourceRef: {
            '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
            withApiGroup(apiGroup): { spec+: { dataSourceRef+: { apiGroup: apiGroup } } },
            '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
            withKind(kind): { spec+: { dataSourceRef+: { kind: kind } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { dataSourceRef+: { name: name } } },
            '#withNamespace':: d.fn(help='', args=[d.arg(name='namespace', type=d.T.string)]),
            withNamespace(namespace): { spec+: { dataSourceRef+: { namespace: namespace } } },
          },
          '#resources':: d.obj(help=''),
          resources: {
            '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
            withLimits(limits): { spec+: { resources+: { limits: limits } } },
            '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
            withLimitsMixin(limits): { spec+: { resources+: { limits+: limits } } },
            '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
            withRequests(requests): { spec+: { resources+: { requests: requests } } },
            '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
            withRequestsMixin(requests): { spec+: { resources+: { requests+: requests } } },
          },
          '#selector':: d.obj(help=''),
          selector: {
            '#matchExpressions':: d.obj(help=''),
            matchExpressions: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressions(matchExpressions): { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
            '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressionsMixin(matchExpressions): { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
            '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { spec+: { selector+: { matchLabels: matchLabels } } },
            '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { spec+: { selector+: { matchLabels+: matchLabels } } },
          },
          '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
          withAccessModes(accessModes): { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } },
          '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
          withAccessModesMixin(accessModes): { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } },
          '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
          withStorageClassName(storageClassName): { spec+: { storageClassName: storageClassName } },
          '#withVolumeAttributesClassName':: d.fn(help='', args=[d.arg(name='volumeAttributesClassName', type=d.T.string)]),
          withVolumeAttributesClassName(volumeAttributesClassName): { spec+: { volumeAttributesClassName: volumeAttributesClassName } },
          '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
          withVolumeMode(volumeMode): { spec+: { volumeMode: volumeMode } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { spec+: { volumeName: volumeName } },
        },
        '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
        withApiVersion(apiVersion): { apiVersion: apiVersion },
        '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
        withKind(kind): { kind: kind },
      },
      '#volumes':: d.obj(help=''),
      volumes: {
        '#awsElasticBlockStore':: d.obj(help=''),
        awsElasticBlockStore: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { awsElasticBlockStore+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { awsElasticBlockStore+: { partition: partition } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { awsElasticBlockStore+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { awsElasticBlockStore+: { volumeID: volumeID } },
        },
        '#azureDisk':: d.obj(help=''),
        azureDisk: {
          '#withCachingMode':: d.fn(help='', args=[d.arg(name='cachingMode', type=d.T.string)]),
          withCachingMode(cachingMode): { azureDisk+: { cachingMode: cachingMode } },
          '#withDiskName':: d.fn(help='', args=[d.arg(name='diskName', type=d.T.string)]),
          withDiskName(diskName): { azureDisk+: { diskName: diskName } },
          '#withDiskURI':: d.fn(help='', args=[d.arg(name='diskURI', type=d.T.string)]),
          withDiskURI(diskURI): { azureDisk+: { diskURI: diskURI } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { azureDisk+: { fsType: fsType } },
          '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
          withKind(kind): { azureDisk+: { kind: kind } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureDisk+: { readOnly: readOnly } },
        },
        '#azureFile':: d.obj(help=''),
        azureFile: {
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { azureFile+: { readOnly: readOnly } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { azureFile+: { secretName: secretName } },
          '#withShareName':: d.fn(help='', args=[d.arg(name='shareName', type=d.T.string)]),
          withShareName(shareName): { azureFile+: { shareName: shareName } },
        },
        '#cephfs':: d.obj(help=''),
        cephfs: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cephfs+: { secretRef+: { name: name } } },
          },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { cephfs+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { cephfs+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { cephfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cephfs+: { readOnly: readOnly } },
          '#withSecretFile':: d.fn(help='', args=[d.arg(name='secretFile', type=d.T.string)]),
          withSecretFile(secretFile): { cephfs+: { secretFile: secretFile } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { cephfs+: { user: user } },
        },
        '#cinder':: d.obj(help=''),
        cinder: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { cinder+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { cinder+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { cinder+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { cinder+: { volumeID: volumeID } },
        },
        '#configMap':: d.obj(help=''),
        configMap: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { configMap+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { configMap+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { configMap+: { optional: optional } },
        },
        '#csi':: d.obj(help=''),
        csi: {
          '#nodePublishSecretRef':: d.obj(help=''),
          nodePublishSecretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { csi+: { nodePublishSecretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { csi+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { csi+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { csi+: { readOnly: readOnly } },
          '#withVolumeAttributes':: d.fn(help='', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributes(volumeAttributes): { csi+: { volumeAttributes: volumeAttributes } },
          '#withVolumeAttributesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeAttributes', type=d.T.object)]),
          withVolumeAttributesMixin(volumeAttributes): { csi+: { volumeAttributes+: volumeAttributes } },
        },
        '#downwardAPI':: d.obj(help=''),
        downwardAPI: {
          '#items':: d.obj(help=''),
          items: {
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { resourceFieldRef+: { resource: resource } },
            },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { downwardAPI+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
        },
        '#emptyDir':: d.obj(help=''),
        emptyDir: {
          '#withMedium':: d.fn(help='', args=[d.arg(name='medium', type=d.T.string)]),
          withMedium(medium): { emptyDir+: { medium: medium } },
          '#withSizeLimit':: d.fn(help='', args=[d.arg(name='sizeLimit', type=d.T.any)]),
          withSizeLimit(sizeLimit): { emptyDir+: { sizeLimit: sizeLimit } },
        },
        '#ephemeral':: d.obj(help=''),
        ephemeral: {
          '#volumeClaimTemplate':: d.obj(help=''),
          volumeClaimTemplate: {
            '#metadata':: d.obj(help=''),
            metadata: {
              '#withAnnotations':: d.fn(help='', args=[d.arg(name='annotations', type=d.T.object)]),
              withAnnotations(annotations): { ephemeral+: { volumeClaimTemplate+: { metadata+: { annotations: annotations } } } },
              '#withAnnotationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
              withAnnotationsMixin(annotations): { ephemeral+: { volumeClaimTemplate+: { metadata+: { annotations+: annotations } } } },
              '#withFinalizers':: d.fn(help='', args=[d.arg(name='finalizers', type=d.T.array)]),
              withFinalizers(finalizers): { ephemeral+: { volumeClaimTemplate+: { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } } } },
              '#withFinalizersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
              withFinalizersMixin(finalizers): { ephemeral+: { volumeClaimTemplate+: { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } } } },
              '#withLabels':: d.fn(help='', args=[d.arg(name='labels', type=d.T.object)]),
              withLabels(labels): { ephemeral+: { volumeClaimTemplate+: { metadata+: { labels: labels } } } },
              '#withLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
              withLabelsMixin(labels): { ephemeral+: { volumeClaimTemplate+: { metadata+: { labels+: labels } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { ephemeral+: { volumeClaimTemplate+: { metadata+: { name: name } } } },
              '#withNamespace':: d.fn(help='', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { ephemeral+: { volumeClaimTemplate+: { metadata+: { namespace: namespace } } } },
            },
            '#spec':: d.obj(help=''),
            spec: {
              '#dataSource':: d.obj(help=''),
              dataSource: {
                '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { apiGroup: apiGroup } } } } },
                '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { kind: kind } } } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSource+: { name: name } } } } },
              },
              '#dataSourceRef':: d.obj(help=''),
              dataSourceRef: {
                '#withApiGroup':: d.fn(help='', args=[d.arg(name='apiGroup', type=d.T.string)]),
                withApiGroup(apiGroup): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSourceRef+: { apiGroup: apiGroup } } } } },
                '#withKind':: d.fn(help='', args=[d.arg(name='kind', type=d.T.string)]),
                withKind(kind): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSourceRef+: { kind: kind } } } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSourceRef+: { name: name } } } } },
                '#withNamespace':: d.fn(help='', args=[d.arg(name='namespace', type=d.T.string)]),
                withNamespace(namespace): { ephemeral+: { volumeClaimTemplate+: { spec+: { dataSourceRef+: { namespace: namespace } } } } },
              },
              '#resources':: d.obj(help=''),
              resources: {
                '#withLimits':: d.fn(help='', args=[d.arg(name='limits', type=d.T.object)]),
                withLimits(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits: limits } } } } },
                '#withLimitsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
                withLimitsMixin(limits): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { limits+: limits } } } } },
                '#withRequests':: d.fn(help='', args=[d.arg(name='requests', type=d.T.object)]),
                withRequests(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests: requests } } } } },
                '#withRequestsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
                withRequestsMixin(requests): { ephemeral+: { volumeClaimTemplate+: { spec+: { resources+: { requests+: requests } } } } },
              },
              '#selector':: d.obj(help=''),
              selector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels: matchLabels } } } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { ephemeral+: { volumeClaimTemplate+: { spec+: { selector+: { matchLabels+: matchLabels } } } } },
              },
              '#withAccessModes':: d.fn(help='', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModes(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withAccessModesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='accessModes', type=d.T.array)]),
              withAccessModesMixin(accessModes): { ephemeral+: { volumeClaimTemplate+: { spec+: { accessModes+: if std.isArray(v=accessModes) then accessModes else [accessModes] } } } },
              '#withStorageClassName':: d.fn(help='', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { storageClassName: storageClassName } } } },
              '#withVolumeAttributesClassName':: d.fn(help='', args=[d.arg(name='volumeAttributesClassName', type=d.T.string)]),
              withVolumeAttributesClassName(volumeAttributesClassName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeAttributesClassName: volumeAttributesClassName } } } },
              '#withVolumeMode':: d.fn(help='', args=[d.arg(name='volumeMode', type=d.T.string)]),
              withVolumeMode(volumeMode): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeMode: volumeMode } } } },
              '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
              withVolumeName(volumeName): { ephemeral+: { volumeClaimTemplate+: { spec+: { volumeName: volumeName } } } },
            },
          },
        },
        '#fc':: d.obj(help=''),
        fc: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { fc+: { fsType: fsType } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { fc+: { lun: lun } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { fc+: { readOnly: readOnly } },
          '#withTargetWWNs':: d.fn(help='', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNs(targetWWNs): { fc+: { targetWWNs: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withTargetWWNsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetWWNs', type=d.T.array)]),
          withTargetWWNsMixin(targetWWNs): { fc+: { targetWWNs+: if std.isArray(v=targetWWNs) then targetWWNs else [targetWWNs] } },
          '#withWwids':: d.fn(help='', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwids(wwids): { fc+: { wwids: if std.isArray(v=wwids) then wwids else [wwids] } },
          '#withWwidsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wwids', type=d.T.array)]),
          withWwidsMixin(wwids): { fc+: { wwids+: if std.isArray(v=wwids) then wwids else [wwids] } },
        },
        '#flexVolume':: d.obj(help=''),
        flexVolume: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { flexVolume+: { secretRef+: { name: name } } },
          },
          '#withDriver':: d.fn(help='', args=[d.arg(name='driver', type=d.T.string)]),
          withDriver(driver): { flexVolume+: { driver: driver } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { flexVolume+: { fsType: fsType } },
          '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.object)]),
          withOptions(options): { flexVolume+: { options: options } },
          '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.object)]),
          withOptionsMixin(options): { flexVolume+: { options+: options } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { flexVolume+: { readOnly: readOnly } },
        },
        '#flocker':: d.obj(help=''),
        flocker: {
          '#withDatasetName':: d.fn(help='', args=[d.arg(name='datasetName', type=d.T.string)]),
          withDatasetName(datasetName): { flocker+: { datasetName: datasetName } },
          '#withDatasetUUID':: d.fn(help='', args=[d.arg(name='datasetUUID', type=d.T.string)]),
          withDatasetUUID(datasetUUID): { flocker+: { datasetUUID: datasetUUID } },
        },
        '#gcePersistentDisk':: d.obj(help=''),
        gcePersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { gcePersistentDisk+: { fsType: fsType } },
          '#withPartition':: d.fn(help='', args=[d.arg(name='partition', type=d.T.integer)]),
          withPartition(partition): { gcePersistentDisk+: { partition: partition } },
          '#withPdName':: d.fn(help='', args=[d.arg(name='pdName', type=d.T.string)]),
          withPdName(pdName): { gcePersistentDisk+: { pdName: pdName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { gcePersistentDisk+: { readOnly: readOnly } },
        },
        '#gitRepo':: d.obj(help=''),
        gitRepo: {
          '#withDirectory':: d.fn(help='', args=[d.arg(name='directory', type=d.T.string)]),
          withDirectory(directory): { gitRepo+: { directory: directory } },
          '#withRepository':: d.fn(help='', args=[d.arg(name='repository', type=d.T.string)]),
          withRepository(repository): { gitRepo+: { repository: repository } },
          '#withRevision':: d.fn(help='', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { gitRepo+: { revision: revision } },
        },
        '#glusterfs':: d.obj(help=''),
        glusterfs: {
          '#withEndpoints':: d.fn(help='', args=[d.arg(name='endpoints', type=d.T.string)]),
          withEndpoints(endpoints): { glusterfs+: { endpoints: endpoints } },
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { glusterfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { glusterfs+: { readOnly: readOnly } },
        },
        '#hostPath':: d.obj(help=''),
        hostPath: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { hostPath+: { path: path } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { hostPath+: { type: type } },
        },
        '#iscsi':: d.obj(help=''),
        iscsi: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { iscsi+: { secretRef+: { name: name } } },
          },
          '#withChapAuthDiscovery':: d.fn(help='', args=[d.arg(name='chapAuthDiscovery', type=d.T.boolean)]),
          withChapAuthDiscovery(chapAuthDiscovery): { iscsi+: { chapAuthDiscovery: chapAuthDiscovery } },
          '#withChapAuthSession':: d.fn(help='', args=[d.arg(name='chapAuthSession', type=d.T.boolean)]),
          withChapAuthSession(chapAuthSession): { iscsi+: { chapAuthSession: chapAuthSession } },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { iscsi+: { fsType: fsType } },
          '#withInitiatorName':: d.fn(help='', args=[d.arg(name='initiatorName', type=d.T.string)]),
          withInitiatorName(initiatorName): { iscsi+: { initiatorName: initiatorName } },
          '#withIqn':: d.fn(help='', args=[d.arg(name='iqn', type=d.T.string)]),
          withIqn(iqn): { iscsi+: { iqn: iqn } },
          '#withIscsiInterface':: d.fn(help='', args=[d.arg(name='iscsiInterface', type=d.T.string)]),
          withIscsiInterface(iscsiInterface): { iscsi+: { iscsiInterface: iscsiInterface } },
          '#withLun':: d.fn(help='', args=[d.arg(name='lun', type=d.T.integer)]),
          withLun(lun): { iscsi+: { lun: lun } },
          '#withPortals':: d.fn(help='', args=[d.arg(name='portals', type=d.T.array)]),
          withPortals(portals): { iscsi+: { portals: if std.isArray(v=portals) then portals else [portals] } },
          '#withPortalsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='portals', type=d.T.array)]),
          withPortalsMixin(portals): { iscsi+: { portals+: if std.isArray(v=portals) then portals else [portals] } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { iscsi+: { readOnly: readOnly } },
          '#withTargetPortal':: d.fn(help='', args=[d.arg(name='targetPortal', type=d.T.string)]),
          withTargetPortal(targetPortal): { iscsi+: { targetPortal: targetPortal } },
        },
        '#nfs':: d.obj(help=''),
        nfs: {
          '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { nfs+: { path: path } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { nfs+: { readOnly: readOnly } },
          '#withServer':: d.fn(help='', args=[d.arg(name='server', type=d.T.string)]),
          withServer(server): { nfs+: { server: server } },
        },
        '#persistentVolumeClaim':: d.obj(help=''),
        persistentVolumeClaim: {
          '#withClaimName':: d.fn(help='', args=[d.arg(name='claimName', type=d.T.string)]),
          withClaimName(claimName): { persistentVolumeClaim+: { claimName: claimName } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { persistentVolumeClaim+: { readOnly: readOnly } },
        },
        '#photonPersistentDisk':: d.obj(help=''),
        photonPersistentDisk: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { photonPersistentDisk+: { fsType: fsType } },
          '#withPdID':: d.fn(help='', args=[d.arg(name='pdID', type=d.T.string)]),
          withPdID(pdID): { photonPersistentDisk+: { pdID: pdID } },
        },
        '#portworxVolume':: d.obj(help=''),
        portworxVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { portworxVolume+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { portworxVolume+: { readOnly: readOnly } },
          '#withVolumeID':: d.fn(help='', args=[d.arg(name='volumeID', type=d.T.string)]),
          withVolumeID(volumeID): { portworxVolume+: { volumeID: volumeID } },
        },
        '#projected':: d.obj(help=''),
        projected: {
          '#sources':: d.obj(help=''),
          sources: {
            '#clusterTrustBundle':: d.obj(help=''),
            clusterTrustBundle: {
              '#labelSelector':: d.obj(help=''),
              labelSelector: {
                '#matchExpressions':: d.obj(help=''),
                matchExpressions: {
                  '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { key: key },
                  '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                  withOperator(operator): { operator: operator },
                  '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                  withValues(values): { values: if std.isArray(v=values) then values else [values] },
                  '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                  withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
                },
                '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressions(matchExpressions): { clusterTrustBundle+: { labelSelector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
                withMatchExpressionsMixin(matchExpressions): { clusterTrustBundle+: { labelSelector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } } },
                '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { clusterTrustBundle+: { labelSelector+: { matchLabels: matchLabels } } },
                '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { clusterTrustBundle+: { labelSelector+: { matchLabels+: matchLabels } } },
              },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { clusterTrustBundle+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { clusterTrustBundle+: { optional: optional } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { clusterTrustBundle+: { path: path } },
              '#withSignerName':: d.fn(help='', args=[d.arg(name='signerName', type=d.T.string)]),
              withSignerName(signerName): { clusterTrustBundle+: { signerName: signerName } },
            },
            '#configMap':: d.obj(help=''),
            configMap: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { configMap+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { configMap+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMap+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMap+: { optional: optional } },
            },
            '#downwardAPI':: d.obj(help=''),
            downwardAPI: {
              '#items':: d.obj(help=''),
              items: {
                '#fieldRef':: d.obj(help=''),
                fieldRef: {
                  '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                  withApiVersion(apiVersion): { fieldRef+: { apiVersion: apiVersion } },
                  '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                  withFieldPath(fieldPath): { fieldRef+: { fieldPath: fieldPath } },
                },
                '#resourceFieldRef':: d.obj(help=''),
                resourceFieldRef: {
                  '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                  withContainerName(containerName): { resourceFieldRef+: { containerName: containerName } },
                  '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                  withDivisor(divisor): { resourceFieldRef+: { divisor: divisor } },
                  '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                  withResource(resource): { resourceFieldRef+: { resource: resource } },
                },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { downwardAPI+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { downwardAPI+: { items+: if std.isArray(v=items) then items else [items] } },
            },
            '#secret':: d.obj(help=''),
            secret: {
              '#items':: d.obj(help=''),
              items: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
                withMode(mode): { mode: mode },
                '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
                withPath(path): { path: path },
              },
              '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
              withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
              '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
              withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secret+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secret+: { optional: optional } },
            },
            '#serviceAccountToken':: d.obj(help=''),
            serviceAccountToken: {
              '#withAudience':: d.fn(help='', args=[d.arg(name='audience', type=d.T.string)]),
              withAudience(audience): { serviceAccountToken+: { audience: audience } },
              '#withExpirationSeconds':: d.fn(help='', args=[d.arg(name='expirationSeconds', type=d.T.integer)]),
              withExpirationSeconds(expirationSeconds): { serviceAccountToken+: { expirationSeconds: expirationSeconds } },
              '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
              withPath(path): { serviceAccountToken+: { path: path } },
            },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { projected+: { defaultMode: defaultMode } },
          '#withSources':: d.fn(help='', args=[d.arg(name='sources', type=d.T.array)]),
          withSources(sources): { projected+: { sources: if std.isArray(v=sources) then sources else [sources] } },
          '#withSourcesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sources', type=d.T.array)]),
          withSourcesMixin(sources): { projected+: { sources+: if std.isArray(v=sources) then sources else [sources] } },
        },
        '#quobyte':: d.obj(help=''),
        quobyte: {
          '#withGroup':: d.fn(help='', args=[d.arg(name='group', type=d.T.string)]),
          withGroup(group): { quobyte+: { group: group } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { quobyte+: { readOnly: readOnly } },
          '#withRegistry':: d.fn(help='', args=[d.arg(name='registry', type=d.T.string)]),
          withRegistry(registry): { quobyte+: { registry: registry } },
          '#withTenant':: d.fn(help='', args=[d.arg(name='tenant', type=d.T.string)]),
          withTenant(tenant): { quobyte+: { tenant: tenant } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { quobyte+: { user: user } },
          '#withVolume':: d.fn(help='', args=[d.arg(name='volume', type=d.T.string)]),
          withVolume(volume): { quobyte+: { volume: volume } },
        },
        '#rbd':: d.obj(help=''),
        rbd: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { rbd+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { rbd+: { fsType: fsType } },
          '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { rbd+: { image: image } },
          '#withKeyring':: d.fn(help='', args=[d.arg(name='keyring', type=d.T.string)]),
          withKeyring(keyring): { rbd+: { keyring: keyring } },
          '#withMonitors':: d.fn(help='', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitors(monitors): { rbd+: { monitors: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withMonitorsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='monitors', type=d.T.array)]),
          withMonitorsMixin(monitors): { rbd+: { monitors+: if std.isArray(v=monitors) then monitors else [monitors] } },
          '#withPool':: d.fn(help='', args=[d.arg(name='pool', type=d.T.string)]),
          withPool(pool): { rbd+: { pool: pool } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { rbd+: { readOnly: readOnly } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { rbd+: { user: user } },
        },
        '#scaleIO':: d.obj(help=''),
        scaleIO: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { scaleIO+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { scaleIO+: { fsType: fsType } },
          '#withGateway':: d.fn(help='', args=[d.arg(name='gateway', type=d.T.string)]),
          withGateway(gateway): { scaleIO+: { gateway: gateway } },
          '#withProtectionDomain':: d.fn(help='', args=[d.arg(name='protectionDomain', type=d.T.string)]),
          withProtectionDomain(protectionDomain): { scaleIO+: { protectionDomain: protectionDomain } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { scaleIO+: { readOnly: readOnly } },
          '#withSslEnabled':: d.fn(help='', args=[d.arg(name='sslEnabled', type=d.T.boolean)]),
          withSslEnabled(sslEnabled): { scaleIO+: { sslEnabled: sslEnabled } },
          '#withStorageMode':: d.fn(help='', args=[d.arg(name='storageMode', type=d.T.string)]),
          withStorageMode(storageMode): { scaleIO+: { storageMode: storageMode } },
          '#withStoragePool':: d.fn(help='', args=[d.arg(name='storagePool', type=d.T.string)]),
          withStoragePool(storagePool): { scaleIO+: { storagePool: storagePool } },
          '#withSystem':: d.fn(help='', args=[d.arg(name='system', type=d.T.string)]),
          withSystem(system): { scaleIO+: { system: system } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { scaleIO+: { volumeName: volumeName } },
        },
        '#secret':: d.obj(help=''),
        secret: {
          '#items':: d.obj(help=''),
          items: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { key: key },
            '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.integer)]),
            withMode(mode): { mode: mode },
            '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
          },
          '#withDefaultMode':: d.fn(help='', args=[d.arg(name='defaultMode', type=d.T.integer)]),
          withDefaultMode(defaultMode): { secret+: { defaultMode: defaultMode } },
          '#withItems':: d.fn(help='', args=[d.arg(name='items', type=d.T.array)]),
          withItems(items): { secret+: { items: if std.isArray(v=items) then items else [items] } },
          '#withItemsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='items', type=d.T.array)]),
          withItemsMixin(items): { secret+: { items+: if std.isArray(v=items) then items else [items] } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { secret+: { optional: optional } },
          '#withSecretName':: d.fn(help='', args=[d.arg(name='secretName', type=d.T.string)]),
          withSecretName(secretName): { secret+: { secretName: secretName } },
        },
        '#storageos':: d.obj(help=''),
        storageos: {
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { storageos+: { secretRef+: { name: name } } },
          },
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { storageos+: { fsType: fsType } },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { storageos+: { readOnly: readOnly } },
          '#withVolumeName':: d.fn(help='', args=[d.arg(name='volumeName', type=d.T.string)]),
          withVolumeName(volumeName): { storageos+: { volumeName: volumeName } },
          '#withVolumeNamespace':: d.fn(help='', args=[d.arg(name='volumeNamespace', type=d.T.string)]),
          withVolumeNamespace(volumeNamespace): { storageos+: { volumeNamespace: volumeNamespace } },
        },
        '#vsphereVolume':: d.obj(help=''),
        vsphereVolume: {
          '#withFsType':: d.fn(help='', args=[d.arg(name='fsType', type=d.T.string)]),
          withFsType(fsType): { vsphereVolume+: { fsType: fsType } },
          '#withStoragePolicyID':: d.fn(help='', args=[d.arg(name='storagePolicyID', type=d.T.string)]),
          withStoragePolicyID(storagePolicyID): { vsphereVolume+: { storagePolicyID: storagePolicyID } },
          '#withStoragePolicyName':: d.fn(help='', args=[d.arg(name='storagePolicyName', type=d.T.string)]),
          withStoragePolicyName(storagePolicyName): { vsphereVolume+: { storagePolicyName: storagePolicyName } },
          '#withVolumePath':: d.fn(help='', args=[d.arg(name='volumePath', type=d.T.string)]),
          withVolumePath(volumePath): { vsphereVolume+: { volumePath: volumePath } },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#withContainers':: d.fn(help='', args=[d.arg(name='containers', type=d.T.array)]),
      withContainers(containers): { spec+: { sideCars+: { containers: if std.isArray(v=containers) then containers else [containers] } } },
      '#withContainersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='containers', type=d.T.array)]),
      withContainersMixin(containers): { spec+: { sideCars+: { containers+: if std.isArray(v=containers) then containers else [containers] } } },
      '#withVolumeClaimTemplates':: d.fn(help='', args=[d.arg(name='volumeClaimTemplates', type=d.T.array)]),
      withVolumeClaimTemplates(volumeClaimTemplates): { spec+: { sideCars+: { volumeClaimTemplates: if std.isArray(v=volumeClaimTemplates) then volumeClaimTemplates else [volumeClaimTemplates] } } },
      '#withVolumeClaimTemplatesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeClaimTemplates', type=d.T.array)]),
      withVolumeClaimTemplatesMixin(volumeClaimTemplates): { spec+: { sideCars+: { volumeClaimTemplates+: if std.isArray(v=volumeClaimTemplates) then volumeClaimTemplates else [volumeClaimTemplates] } } },
      '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumes(volumes): { spec+: { sideCars+: { volumes: if std.isArray(v=volumes) then volumes else [volumes] } } },
      '#withVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumes', type=d.T.array)]),
      withVolumesMixin(volumes): { spec+: { sideCars+: { volumes+: if std.isArray(v=volumes) then volumes else [volumes] } } },
    },
    '#startup':: d.obj(help=''),
    startup: {
      '#exec':: d.obj(help=''),
      exec: {
        '#withCommand':: d.fn(help='', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { spec+: { startup+: { exec+: { command: if std.isArray(v=command) then command else [command] } } } },
        '#withCommandMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { spec+: { startup+: { exec+: { command+: if std.isArray(v=command) then command else [command] } } } },
      },
      '#grpc':: d.obj(help=''),
      grpc: {
        '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.integer)]),
        withPort(port): { spec+: { startup+: { grpc+: { port: port } } } },
        '#withService':: d.fn(help='', args=[d.arg(name='service', type=d.T.string)]),
        withService(service): { spec+: { startup+: { grpc+: { service: service } } } },
      },
      '#httpGet':: d.obj(help=''),
      httpGet: {
        '#httpHeaders':: d.obj(help=''),
        httpHeaders: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
        withHost(host): { spec+: { startup+: { httpGet+: { host: host } } } },
        '#withHttpHeaders':: d.fn(help='', args=[d.arg(name='httpHeaders', type=d.T.array)]),
        withHttpHeaders(httpHeaders): { spec+: { startup+: { httpGet+: { httpHeaders: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
        '#withHttpHeadersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpHeaders', type=d.T.array)]),
        withHttpHeadersMixin(httpHeaders): { spec+: { startup+: { httpGet+: { httpHeaders+: if std.isArray(v=httpHeaders) then httpHeaders else [httpHeaders] } } } },
        '#withPath':: d.fn(help='', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { spec+: { startup+: { httpGet+: { path: path } } } },
        '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
        withPort(port): { spec+: { startup+: { httpGet+: { port: port } } } },
        '#withScheme':: d.fn(help='', args=[d.arg(name='scheme', type=d.T.string)]),
        withScheme(scheme): { spec+: { startup+: { httpGet+: { scheme: scheme } } } },
      },
      '#tcpSocket':: d.obj(help=''),
      tcpSocket: {
        '#withHost':: d.fn(help='', args=[d.arg(name='host', type=d.T.string)]),
        withHost(host): { spec+: { startup+: { tcpSocket+: { host: host } } } },
        '#withPort':: d.fn(help='', args=[d.arg(name='port', type=d.T.any)]),
        withPort(port): { spec+: { startup+: { tcpSocket+: { port: port } } } },
      },
      '#withFailureThreshold':: d.fn(help='', args=[d.arg(name='failureThreshold', type=d.T.integer)]),
      withFailureThreshold(failureThreshold): { spec+: { startup+: { failureThreshold: failureThreshold } } },
      '#withInitialDelaySeconds':: d.fn(help='', args=[d.arg(name='initialDelaySeconds', type=d.T.integer)]),
      withInitialDelaySeconds(initialDelaySeconds): { spec+: { startup+: { initialDelaySeconds: initialDelaySeconds } } },
      '#withPeriodSeconds':: d.fn(help='', args=[d.arg(name='periodSeconds', type=d.T.integer)]),
      withPeriodSeconds(periodSeconds): { spec+: { startup+: { periodSeconds: periodSeconds } } },
      '#withSuccessThreshold':: d.fn(help='', args=[d.arg(name='successThreshold', type=d.T.integer)]),
      withSuccessThreshold(successThreshold): { spec+: { startup+: { successThreshold: successThreshold } } },
      '#withTerminationGracePeriodSeconds':: d.fn(help='', args=[d.arg(name='terminationGracePeriodSeconds', type=d.T.integer)]),
      withTerminationGracePeriodSeconds(terminationGracePeriodSeconds): { spec+: { startup+: { terminationGracePeriodSeconds: terminationGracePeriodSeconds } } },
      '#withTimeoutSeconds':: d.fn(help='', args=[d.arg(name='timeoutSeconds', type=d.T.integer)]),
      withTimeoutSeconds(timeoutSeconds): { spec+: { startup+: { timeoutSeconds: timeoutSeconds } } },
    },
    '#users':: d.obj(help=''),
    users: {
      '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
    },
    '#withAdditionalVolumeMounts':: d.fn(help='', args=[d.arg(name='additionalVolumeMounts', type=d.T.array)]),
    withAdditionalVolumeMounts(additionalVolumeMounts): { spec+: { additionalVolumeMounts: if std.isArray(v=additionalVolumeMounts) then additionalVolumeMounts else [additionalVolumeMounts] } },
    '#withAdditionalVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='additionalVolumeMounts', type=d.T.array)]),
    withAdditionalVolumeMountsMixin(additionalVolumeMounts): { spec+: { additionalVolumeMounts+: if std.isArray(v=additionalVolumeMounts) then additionalVolumeMounts else [additionalVolumeMounts] } },
    '#withAdditionalVolumes':: d.fn(help='', args=[d.arg(name='additionalVolumes', type=d.T.array)]),
    withAdditionalVolumes(additionalVolumes): { spec+: { additionalVolumes: if std.isArray(v=additionalVolumes) then additionalVolumes else [additionalVolumes] } },
    '#withAdditionalVolumesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='additionalVolumes', type=d.T.array)]),
    withAdditionalVolumesMixin(additionalVolumes): { spec+: { additionalVolumes+: if std.isArray(v=additionalVolumes) then additionalVolumes else [additionalVolumes] } },
    '#withBuckets':: d.fn(help='', args=[d.arg(name='buckets', type=d.T.array)]),
    withBuckets(buckets): { spec+: { buckets: if std.isArray(v=buckets) then buckets else [buckets] } },
    '#withBucketsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='buckets', type=d.T.array)]),
    withBucketsMixin(buckets): { spec+: { buckets+: if std.isArray(v=buckets) then buckets else [buckets] } },
    '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
    withEnv(env): { spec+: { env: if std.isArray(v=env) then env else [env] } },
    '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
    withEnvMixin(env): { spec+: { env+: if std.isArray(v=env) then env else [env] } },
    '#withExternalCaCertSecret':: d.fn(help='', args=[d.arg(name='externalCaCertSecret', type=d.T.array)]),
    withExternalCaCertSecret(externalCaCertSecret): { spec+: { externalCaCertSecret: if std.isArray(v=externalCaCertSecret) then externalCaCertSecret else [externalCaCertSecret] } },
    '#withExternalCaCertSecretMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='externalCaCertSecret', type=d.T.array)]),
    withExternalCaCertSecretMixin(externalCaCertSecret): { spec+: { externalCaCertSecret+: if std.isArray(v=externalCaCertSecret) then externalCaCertSecret else [externalCaCertSecret] } },
    '#withExternalCertSecret':: d.fn(help='', args=[d.arg(name='externalCertSecret', type=d.T.array)]),
    withExternalCertSecret(externalCertSecret): { spec+: { externalCertSecret: if std.isArray(v=externalCertSecret) then externalCertSecret else [externalCertSecret] } },
    '#withExternalCertSecretMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='externalCertSecret', type=d.T.array)]),
    withExternalCertSecretMixin(externalCertSecret): { spec+: { externalCertSecret+: if std.isArray(v=externalCertSecret) then externalCertSecret else [externalCertSecret] } },
    '#withExternalClientCertSecrets':: d.fn(help='', args=[d.arg(name='externalClientCertSecrets', type=d.T.array)]),
    withExternalClientCertSecrets(externalClientCertSecrets): { spec+: { externalClientCertSecrets: if std.isArray(v=externalClientCertSecrets) then externalClientCertSecrets else [externalClientCertSecrets] } },
    '#withExternalClientCertSecretsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='externalClientCertSecrets', type=d.T.array)]),
    withExternalClientCertSecretsMixin(externalClientCertSecrets): { spec+: { externalClientCertSecrets+: if std.isArray(v=externalClientCertSecrets) then externalClientCertSecrets else [externalClientCertSecrets] } },
    '#withImage':: d.fn(help='', args=[d.arg(name='image', type=d.T.string)]),
    withImage(image): { spec+: { image: image } },
    '#withImagePullPolicy':: d.fn(help='', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
    withImagePullPolicy(imagePullPolicy): { spec+: { imagePullPolicy: imagePullPolicy } },
    '#withInitContainers':: d.fn(help='', args=[d.arg(name='initContainers', type=d.T.array)]),
    withInitContainers(initContainers): { spec+: { initContainers: if std.isArray(v=initContainers) then initContainers else [initContainers] } },
    '#withInitContainersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='initContainers', type=d.T.array)]),
    withInitContainersMixin(initContainers): { spec+: { initContainers+: if std.isArray(v=initContainers) then initContainers else [initContainers] } },
    '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
    withMountPath(mountPath): { spec+: { mountPath: mountPath } },
    '#withPodManagementPolicy':: d.fn(help='', args=[d.arg(name='podManagementPolicy', type=d.T.string)]),
    withPodManagementPolicy(podManagementPolicy): { spec+: { podManagementPolicy: podManagementPolicy } },
    '#withPools':: d.fn(help='', args=[d.arg(name='pools', type=d.T.array)]),
    withPools(pools): { spec+: { pools: if std.isArray(v=pools) then pools else [pools] } },
    '#withPoolsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pools', type=d.T.array)]),
    withPoolsMixin(pools): { spec+: { pools+: if std.isArray(v=pools) then pools else [pools] } },
    '#withPriorityClassName':: d.fn(help='', args=[d.arg(name='priorityClassName', type=d.T.string)]),
    withPriorityClassName(priorityClassName): { spec+: { priorityClassName: priorityClassName } },
    '#withPrometheusOperator':: d.fn(help='', args=[d.arg(name='prometheusOperator', type=d.T.boolean)]),
    withPrometheusOperator(prometheusOperator): { spec+: { prometheusOperator: prometheusOperator } },
    '#withRequestAutoCert':: d.fn(help='', args=[d.arg(name='requestAutoCert', type=d.T.boolean)]),
    withRequestAutoCert(requestAutoCert): { spec+: { requestAutoCert: requestAutoCert } },
    '#withServiceAccountName':: d.fn(help='', args=[d.arg(name='serviceAccountName', type=d.T.string)]),
    withServiceAccountName(serviceAccountName): { spec+: { serviceAccountName: serviceAccountName } },
    '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
    withSubPath(subPath): { spec+: { subPath: subPath } },
    '#withUsers':: d.fn(help='', args=[d.arg(name='users', type=d.T.array)]),
    withUsers(users): { spec+: { users: if std.isArray(v=users) then users else [users] } },
    '#withUsersMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='users', type=d.T.array)]),
    withUsersMixin(users): { spec+: { users+: if std.isArray(v=users) then users else [users] } },
  },
  '#mixin': 'ignore',
  mixin: self,
}
